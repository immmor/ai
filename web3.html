<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 æ¢ç´¢è€…ï¼šåˆ›ä¸–åŒºå—ä¹‹æ—…</title>
    <script src="web3banks/web3questions.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #00ff41;
            font-family: 'VT323', monospace;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.1);
            border: 2px solid #333;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff41;
        }

        h1 { margin: 0; font-size: 2em; }
        p { margin: 5px 0; font-size: 1.2em; opacity: 0.8; }

        /* Dialogue / Quiz Modal */
        #modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff41;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
        }

        #modal h2 { margin-top: 0; color: #fff; font-size: 1.5em; }
        
        .option-btn {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin: 8px 0;
            background: #003300;
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1em;
            transition: 0.2s;
            box-sizing: border-box;
            min-height: 35px;
        }
        
        /* NFT Collection UI */
        #nft-collection {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ff41;
            padding: 15px;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.3);
            min-width: 200px;
            max-width: 225px;
            max-height: 200px;
            overflow: hidden;
        }
        
        #nft-collection h3 {
            margin: 0 0 10px 0;
            color: #00ff41;
            text-align: center;
            white-space: nowrap;
        }
        
        /* NFTæ»šåŠ¨å®¹å™¨ */
        #nft-items {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
            padding-right: 5px;
        }
        
        /* æ»šåŠ¨æ¡æ ·å¼ */
        #nft-items::-webkit-scrollbar {
            width: 6px;
        }
        
        #nft-items::-webkit-scrollbar-track {
            background: rgba(0, 255, 65, 0.1);
            border-radius: 3px;
        }
        
        #nft-items::-webkit-scrollbar-thumb {
            background: #00ff41;
            border-radius: 3px;
        }
        
        #nft-items::-webkit-scrollbar-thumb:hover {
            background: #00cc33;
        }
        
        .nft-item {
            width: 35px;
            height: 35px;
            background-size: cover;
            border: 1px solid #00ff41;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            flex-shrink: 0;
        }
        
        .nft-item:hover {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.5);
        }
        
        /* Mining Site Indicator */
        .mining-site-indicator {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff9800;
            padding: 10px 15px;
            border-radius: 5px;
            display: none;
            color: #ff9800;
            font-size: 1.1em;
        }
        
        /* Mining Progress Bar */
        #mining-progress {
            width: 100%;
            height: 8px;
            background: #333;
            margin-top: 8px;
            border-radius: 4px;
            overflow: hidden;
        }
        
        #mining-progress-fill {
            height: 100%;
            background: #ff9800;
            width: 0%;
            transition: width 0.5s;
        }
        
        /* å°å±å¹•ä¼˜åŒ– */
        @media screen and (max-width: 600px) {
            #modal {
                width: 95%;
                padding: 15px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            #modal h2 {
                font-size: 1.3em;
                margin-bottom: 15px;
            }
            
            #modal-text {
                font-size: 1.2em;
                line-height: 1.4;
                margin-bottom: 20px;
                font-weight: bold;
            }
            
            .option-btn {
                padding: 12px 10px;
                font-size: 1em;
                margin: 8px 0;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* è§¦æ‘¸å±ä¼˜åŒ– */
        @media (hover: none) and (pointer: coarse) {
            .option-btn {
                padding: 14px 15px;
                font-size: 1.1em;
                margin: 10px 0;
                min-height: 45px;
            }
        }

        .option-btn:hover, .option-btn:active {
            background: #00ff41;
            color: #000;
            transform: scale(1.02);
        }
        
        /* ç¡®ä¿æŒ‰é’®åœ¨å°å±å¹•ä¸Šæœ‰è¶³å¤Ÿçš„è§¦æ‘¸åŒºåŸŸ */
        .option-btn {
            touch-action: manipulation;
            user-select: none;
        }

        #interaction-hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 16px;
    opacity: 0;
    transition: opacity 0.3s;
    cursor: pointer;
    user-select: none;
}

/* è„‰åŠ¨åŠ¨ç”» */
@keyframes pulse {
    0% {
        transform: translateX(-50%) scale(1);
    }
    50% {
        transform: translateX(-50%) scale(1.1);
    }
    100% {
        transform: translateX(-50%) scale(1);
    }
}

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 2em;
            background: #00ff41;
            border: none;
            cursor: pointer;
            font-family: 'VT323', monospace;
            margin-top: 20px;
        }
        
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <h1>WEB3 æ¢ç´¢è€…</h1>
        <p>GASä½™é¢ (åˆ†æ•°): <span id="score">0</span> ETH</p>
        <p>å·²å‡»è´¥æ€ªç‰©: <span id="progress">0</span></p>
        <p>ç”Ÿå‘½å€¼: <span id="health">100</span>%</p>
        <div id="health-bar" style="width: 200px; height: 10px; background: #333; margin-top: 5px;">
            <div id="health-fill" style="width: 100%; height: 100%; background: #ff0000;"></div>
        </div>
    </div>

    <div id="interaction-hint">æŒ‰ [E] æ”»å‡»æ€ªç‰©</div>

    <div id="modal">
        <h2 id="modal-title">èŠ‚ç‚¹æé—®</h2>
        <p id="modal-text">é—®é¢˜å†…å®¹...</p>
        <div id="modal-options"></div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 4em; text-shadow: 0 0 20px #00ff41;">WEB3 UNIVERSE</h1>
        <p>é€šè¿‡å›ç­”é—®é¢˜æ”¶é›†åˆ›ä¸–åŒºå—ï¼Œæˆä¸ºå»ä¸­å¿ƒåŒ–å¤§å¸ˆã€‚</p>
        <button id="start-btn">è¿æ¥ä¸»ç½‘</button>
    </div>
    
    <!-- NFT Collection UI -->
    <div id="nft-collection">
        <h3>NFT æ”¶è— (0)</h3>
        <div id="nft-items"></div>
    </div>
    
    <!-- Mining Site Indicator -->
    <div class="mining-site-indicator" id="mining-indicator">
        <span>åœ¨æŒ–çŸ¿ç‚¹é™„è¿‘ï¼æŒ‰ [M] å¼€å§‹æŒ–çŸ¿</span>
        <div id="mining-progress">
            <div id="mining-progress-fill"></div>
        </div>
    </div>
</div>

<script>
/**
 * Game Configuration & State
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const progressEl = document.getElementById('progress');
const hintEl = document.getElementById('interaction-hint');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalOptions = document.getElementById('modal-options');
const startScreen = document.getElementById('start-screen');

let gameState = 'START'; // START, PLAY, QUIZ, WIN, GAME_OVER
let score = 0;
let defeatedCount = 0;
let lastSpawnTime = 0; // ä¸Šæ¬¡ç”Ÿæˆæ€ªç‰©çš„æ—¶é—´
let currentMonster = null; // å½“å‰æ­£åœ¨æˆ˜æ–—çš„æ€ªç‰©

// ç¨³å®šåŒºé…ç½® - ä¸ç¨³å®šå¸æŒ‚é’©çš„å®‰å…¨åŒºåŸŸ
    const stableZones = [
        { x: 0, y: 0, radius: 150, color: 'rgba(0, 150, 255, 0.3)' }, // ä¸­å¿ƒç¨³å®šåŒº
        { x: 1000, y: 800, radius: 150, color: 'rgba(0, 150, 255, 0.3)' },
        { x: -1200, y: -600, radius: 150, color: 'rgba(0, 150, 255, 0.3)' }
    ];
    
    // åŠ å¯†è´§å¸æŒ–çŸ¿ç‚¹é…ç½®
    const miningSites = [
        { x: 500, y: 300, radius: 100, active: true },
        { x: -800, y: 500, radius: 100, active: true },
        { x: 300, y: -700, radius: 100, active: true },
        { x: -1000, y: -400, radius: 100, active: true }
    ];
    
    // NFTå®šä¹‰
    const nftTypes = [
        { id: 1, name: 'åˆ›ä¸–åŒºå—', rarity: 'common', color: '#ff9800', value: 10, description: 'åŒºå—é“¾çš„ç¬¬ä¸€ä¸ªåŒºå—' },
        { id: 2, name: 'æ¯”ç‰¹å¸æ ‡å¿—', rarity: 'common', color: '#f7931a', value: 15, description: 'æ¯”ç‰¹å¸çš„å®˜æ–¹æ ‡å¿—' },
        { id: 3, name: 'ä»¥å¤ªåŠå›¾æ ‡', rarity: 'common', color: '#627eea', value: 20, description: 'ä»¥å¤ªåŠçš„æ ‡å¿—' },
        { id: 4, name: 'æ™ºèƒ½åˆçº¦', rarity: 'uncommon', color: '#9c27b0', value: 30, description: 'è‡ªåŠ¨æ‰§è¡Œçš„åˆçº¦ä»£ç ' },
        { id: 5, name: 'å»ä¸­å¿ƒåŒ–åº”ç”¨', rarity: 'uncommon', color: '#2196f3', value: 35, description: 'åŸºäºåŒºå—é“¾çš„åº”ç”¨' },
        { id: 6, name: 'DeFiåè®®', rarity: 'rare', color: '#4caf50', value: 50, description: 'å»ä¸­å¿ƒåŒ–é‡‘èåè®®' },
        { id: 7, name: 'DAOç»„ç»‡', rarity: 'rare', color: '#ff5722', value: 60, description: 'å»ä¸­å¿ƒåŒ–è‡ªæ²»ç»„ç»‡' },
        { id: 8, name: 'Web3æŠ¤ç…§', rarity: 'epic', color: '#e91e63', value: 100, description: 'Web3ä¸–ç•Œçš„é€šè¡Œè¯' },
        { id: 9, name: 'å…ƒå®‡å®™ç§å­', rarity: 'legendary', color: '#ffeb3b', value: 200, description: 'å…ƒå®‡å®™çš„èµ·æºç§å­' }
    ];
    
    // ç©å®¶NFTæ”¶è—
    let playerNFTs = [];
    // æ´»è·ƒçš„NFTç‰©å“
    let activeNFTs = [];
    // æŒ–çŸ¿ç›¸å…³å˜é‡
    let currentMiningSite = null;
    let isMining = false;
    let miningProgress = 0;
    const MINING_DURATION = 5000; // 5ç§’æŒ–çŸ¿æ—¶é—´
    let miningStartTime = 0;

// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ç¨³å®šåŒºå†…
function isInStableZone(x, y) {
    return stableZones.some(zone => {
        const dx = x - zone.x;
        const dy = y - zone.y;
        return Math.sqrt(dx*dx + dy*dy) < zone.radius;
    });
}

// æ£€æŸ¥ç‚¹æ˜¯å¦æ¥è¿‘ç¨³å®šåŒºè¾¹ç•Œ
function isNearStableZone(x, y, margin = 20) {
    return stableZones.some(zone => {
        const dx = x - zone.x;
        const dy = y - zone.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        return Math.abs(distance - zone.radius) < margin;
    });
}

// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨æŒ–çŸ¿ç‚¹å†…
// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨æŒ–çŸ¿ç‚¹å†…å¹¶è¿”å›æ‰¾åˆ°çš„æŒ–çŸ¿ç‚¹å¯¹è±¡
function findMiningSite(x, y) {
    return miningSites.find(site => {
        // æŒ–çŸ¿æ—¶ä»ç„¶å¯ä»¥æ£€æµ‹ç©å®¶æ˜¯å¦åœ¨è¯¥ç‚¹èŒƒå›´å†…
        const dx = x - site.x;
        const dy = y - site.y;
        return Math.sqrt(dx*dx + dy*dy) < site.radius;
    });
}

// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ç‰¹å®šæŒ–çŸ¿ç‚¹å†…ï¼ˆç”¨äºæ­£åœ¨æŒ–çŸ¿çš„æƒ…å†µï¼‰
function isInSpecificMiningSite(x, y, targetSite) {
    if (!targetSite) return false;
    const dx = x - targetSite.x;
    const dy = y - targetSite.y;
    // å¢åŠ å®¹å¿åº¦ï¼Œä½¿ç”¨1.5å€çš„åŠå¾„
    return Math.sqrt(dx*dx + dy*dy) < (targetSite.radius * 1.5);
}

// æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨æŒ–çŸ¿ç‚¹å†…ï¼Œè¿”å›å¸ƒå°”å€¼
function isInMiningSite(x, y) {
    return findMiningSite(x, y) !== undefined;
}

// ç”ŸæˆéšæœºNFT
function spawnNFT() {
    // é™åˆ¶åŒæ—¶å­˜åœ¨çš„NFTæ•°é‡
    if (activeNFTs.length >= 5) return;
    
    // éšæœºé€‰æ‹©NFTç±»å‹
    const nftType = nftTypes[Math.floor(Math.random() * nftTypes.length)];
    
    // éšæœºä½ç½®ï¼ˆåœ¨ç©å®¶é™„è¿‘ä½†ä¸åœ¨ç¨³å®šåŒºå†…ï¼‰
    let x, y;
    do {
        const angle = Math.random() * Math.PI * 2;
        const distance = 300 + Math.random() * 500; // 300-800èŒƒå›´å†…
        x = player.x + Math.cos(angle) * distance;
        y = player.y + Math.sin(angle) * distance;
    } while (isInStableZone(x, y));
    
    // åˆ›å»ºNFTå¯¹è±¡
    const nft = {
        id: Date.now(),
        type: nftType,
        x: x,
        y: y,
        size: 30,
        rotation: 0,
        rotationSpeed: (Math.random() - 0.5) * 0.02, // éšæœºæ—‹è½¬é€Ÿåº¦
        collected: false
    };
    
    activeNFTs.push(nft);
}

// æ›´æ–°NFTçŠ¶æ€
function updateNFTs() {
    activeNFTs = activeNFTs.filter(nft => !nft.collected);
    
    activeNFTs.forEach(nft => {
        // æ›´æ–°æ—‹è½¬
        nft.rotation += nft.rotationSpeed;
    });
}

// æ£€æŸ¥NFTç¢°æ’
function checkNFTCollection() {
    activeNFTs.forEach(nft => {
        const dx = player.x - nft.x;
        const dy = player.y - nft.y;
        const distance = Math.sqrt(dx*dx + dy*dy);
        
        if (distance < 40 && !nft.collected) {
            // æ”¶é›†NFT
            nft.collected = true;
            playerNFTs.push(nft.type);
            
            // æ›´æ–°UI
            updateNFTCollectionUI();
            
            // æ˜¾ç¤ºæ”¶é›†é€šçŸ¥
            showNotification(`æ”¶é›†åˆ° NFT: ${nft.type.name} (+${nft.type.value} ETH)`);
            
            // å¢åŠ åˆ†æ•°
            score += nft.type.value;
            scoreEl.innerText = score;
            
            // ç”Ÿæˆæ”¶é›†æ•ˆæœï¼ˆç®€å•çš„ç²’å­æ•ˆæœï¼‰
            for (let i = 0; i < 10; i++) {
                showNotification('âœ¨');
            }
        }
    });
}

// æ›´æ–°NFTæ”¶é›†UI
function updateNFTCollectionUI() {
    const nftCollectionEl = document.getElementById('nft-collection');
    const nftItemsEl = document.getElementById('nft-items');
    
    nftCollectionEl.querySelector('h3').innerText = `NFT æ”¶è— (${playerNFTs.length})`;
    nftItemsEl.innerHTML = '';
    
    // æŒ‰ç¨€æœ‰åº¦åˆ†ç»„NFT
    const rarityGroups = {};
    playerNFTs.forEach(nft => {
        if (!rarityGroups[nft.rarity]) {
            rarityGroups[nft.rarity] = [];
        }
        rarityGroups[nft.rarity].push(nft);
    });
    
    // åˆ›å»ºNFTæ˜¾ç¤º
    playerNFTs.forEach(nft => {
        const nftItem = document.createElement('div');
        nftItem.className = 'nft-item';
        nftItem.style.backgroundColor = nft.color;
        nftItem.title = `${nft.name} (${nft.rarity})\n${nft.description}\nä»·å€¼: ${nft.value} ETH`;
        
        // æ·»åŠ ç¨€æœ‰åº¦è¾¹æ¡†æ•ˆæœ
        if (nft.rarity === 'uncommon') {
            nftItem.style.borderColor = '#4caf50';
            nftItem.style.boxShadow = '0 0 5px #4caf50';
        } else if (nft.rarity === 'rare') {
            nftItem.style.borderColor = '#2196f3';
            nftItem.style.boxShadow = '0 0 5px #2196f3';
        } else if (nft.rarity === 'epic') {
            nftItem.style.borderColor = '#9c27b0';
            nftItem.style.boxShadow = '0 0 5px #9c27b0';
        } else if (nft.rarity === 'legendary') {
            nftItem.style.borderColor = '#ffeb3b';
            nftItem.style.boxShadow = '0 0 5px #ffeb3b';
        }
        
        nftItemsEl.appendChild(nftItem);
    });
}

// å¼€å§‹æŒ–çŸ¿
function startMining() {
    if (isMining || gameState !== 'PLAY') {
        return;
    }
    
    // ç¡®ä¿ç©å®¶ç¡®å®åœ¨æŒ–çŸ¿ç‚¹å†…
    if (!currentMiningSite || !isInSpecificMiningSite(player.x, player.y, currentMiningSite)) {
        showNotification('è¯·å…ˆç§»åŠ¨åˆ°æŒ–çŸ¿ç‚¹å†…');
        return;
    }
    
    isMining = true;
    miningProgress = 0;
    miningStartTime = Date.now();
    
    // æ˜¾ç¤ºæŒ–çŸ¿è¿›åº¦æ¡
    document.getElementById('mining-progress-fill').style.width = '0%';
    
    // ä¸éœ€è¦ç¦ç”¨æŒ–çŸ¿ç‚¹ï¼Œè€Œæ˜¯é€šè¿‡é€»è¾‘åˆ¤æ–­æ¥é˜²æ­¢é‡å¤æŒ–çŸ¿
    
    showNotification('å¼€å§‹æŒ–çŸ¿...');
}

// æ›´æ–°æŒ–çŸ¿è¿›åº¦
function updateMining() {
    if (!isMining) return;
    
    // ç®€åŒ–é€»è¾‘ï¼šä¸å†æ¯å¸§æ£€æŸ¥ä½ç½®ï¼Œç»™ç©å®¶æ›´å¤šå®½å®¹åº¦
    // åªæœ‰åœ¨æ˜æ˜¾ç¦»å¼€æ—¶æ‰ä¼šåœæ­¢æŒ–çŸ¿
    
    const elapsed = Date.now() - miningStartTime;
    miningProgress = Math.min(elapsed / MINING_DURATION, 1);
    
    // æ›´æ–°è¿›åº¦æ¡
    document.getElementById('mining-progress-fill').style.width = `${miningProgress * 100}%`;
    
    // æŒ–çŸ¿å®Œæˆ
    if (miningProgress >= 1) {
        completeMining();
    }
}

// å®ŒæˆæŒ–çŸ¿
function completeMining() {
    isMining = false;
    
    // éšæœºè·å¾—å¥–åŠ±
    const rewardType = Math.random();
    let rewardAmount, rewardText;
    
    if (rewardType < 0.6) { // 60%æ¦‚ç‡è·å¾—ETH
        rewardAmount = Math.floor(Math.random() * 30) + 20; // 20-50 ETH
        rewardText = `æŒ–åˆ° ${rewardAmount} ETH!`;
        score += rewardAmount;
        scoreEl.innerText = score;
    } else if (rewardType < 0.9) { // 30%æ¦‚ç‡è·å¾—ç”Ÿå‘½å€¼æ¢å¤
        rewardAmount = Math.floor(Math.random() * 30) + 20; // 20-50 ç”Ÿå‘½å€¼
        rewardText = `æŒ–åˆ°æ²»ç–—è¯æ°´ +${rewardAmount} ç”Ÿå‘½å€¼!`;
        player.health = Math.min(100, player.health + rewardAmount);
        updateHealthBar();
    } else { // 10%æ¦‚ç‡è·å¾—ç¨€æœ‰NFT
        const rareNFTs = nftTypes.filter(nft => nft.rarity === 'rare' || nft.rarity === 'epic' || nft.rarity === 'legendary');
        if (rareNFTs.length > 0) {
            const nft = rareNFTs[Math.floor(Math.random() * rareNFTs.length)];
            playerNFTs.push(nft);
            updateNFTCollectionUI();
            rewardText = `æŒ–åˆ°ç¨€æœ‰NFT: ${nft.name}!`;
            score += nft.value;
            scoreEl.innerText = score;
        }
    }
    
    showNotification(rewardText);
    
    // 30ç§’åé‡æ–°æ¿€æ´»æŒ–çŸ¿ç‚¹
    setTimeout(() => {
        if (currentMiningSite) {
            currentMiningSite.active = true;
        }
    }, 30000);
}

// æ£€æŸ¥æŒ–çŸ¿ç‚¹äº¤äº’
function checkMiningInteraction() {
    const miningIndicator = document.getElementById('mining-indicator');
    
    if (gameState !== 'PLAY') {
        miningIndicator.style.display = 'none';
        currentMiningSite = null;
        return;
    }
    
    // éæŒ–çŸ¿çŠ¶æ€ä¸‹ï¼Œåªæ£€æµ‹æ¿€æ´»çš„æŒ–çŸ¿ç‚¹
    if (!isMining) {
        const miningSite = miningSites.find(site => {
            if (!site.active) return false;
            const dx = player.x - site.x;
            const dy = player.y - site.y;
            return Math.sqrt(dx*dx + dy*dy) < site.radius;
        });
        
        if (miningSite) {
            currentMiningSite = miningSite;
            miningIndicator.style.display = 'block';
        } else {
            miningIndicator.style.display = 'none';
            currentMiningSite = null;
        }
    } else {
        // æŒ–çŸ¿çŠ¶æ€ä¸‹ï¼Œä½¿ç”¨ç‰¹å®šå‡½æ•°æ£€æŸ¥æ˜¯å¦åœ¨å½“å‰æŒ–çŸ¿ç‚¹èŒƒå›´å†…ï¼Œæä¾›æ›´å¤§å®½å®¹åº¦
        if (!isInSpecificMiningSite(player.x, player.y, currentMiningSite)) {
            // è¿ç»­æ£€æµ‹ä¸¤æ¬¡æ‰å–æ¶ˆæŒ–çŸ¿ï¼Œé¿å…æŠ–åŠ¨é—®é¢˜
            setTimeout(() => {
                if (isMining && !isInSpecificMiningSite(player.x, player.y, currentMiningSite)) {
                    isMining = false;
                    showNotification('ç¦»å¼€æŒ–çŸ¿ç‚¹å¤ªè¿œï¼ŒæŒ–çŸ¿å·²å–æ¶ˆ');
                    document.getElementById('mining-progress-fill').style.width = '0%';
                    // é‡æ–°æ¿€æ´»æŒ–çŸ¿ç‚¹
                    setTimeout(() => {
                        if (currentMiningSite) {
                            currentMiningSite.active = true;
                        }
                    }, 5000);
                }
            }, 1500); // å»¶é•¿è‡³1.5ç§’åå†ç¡®è®¤
        }
    }
}

// Resize canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/**
 * Game Data (The Knowledge Base)
 */

// æ€ªç‰©ç±»å‹å®šä¹‰
const monsterTypes = [
    { type: 'åŒºå—é“¾åƒµå°¸', color: '#ff0055', health: 20, reward: 5, size: 20 },
    { type: 'ç§é’¥çªƒè´¼', color: '#00ccff', health: 35, reward: 10, size: 25 },
    { type: 'Gasæ¶ˆè€—å…½', color: '#ffff00', health: 30, reward: 15, size: 30 },
    { type: 'æ™ºèƒ½åˆçº¦æ¼æ´', color: '#9d00ff', health: 50, reward: 20, size: 35 },
    { type: 'æŒ–çŸ¿éš¾åº¦æ€ª', color: '#ff8800', health: 60, reward: 25, size: 40 },
    { type: 'å…±è¯†ç ´åè€…', color: '#ff6666', health: 40, reward: 18, size: 32 },
    { type: 'å¥³å·«æ”»å‡»è€…', color: '#66ff66', health: 45, reward: 22, size: 28 }
];

// æ´»è·ƒæ€ªç‰©æ•°ç»„
let activeMonsters = [];
// æœ€å¤§åŒæ—¶å­˜åœ¨çš„æ€ªç‰©æ•°é‡
const MAX_MONSTERS = 5;
// æ€ªç‰©ç”Ÿæˆè®¡æ—¶å™¨
let spawnTimer = 0;
// æ€ªç‰©ç”Ÿæˆé—´éš”ï¼ˆæ¯«ç§’ï¼‰
const SPAWN_INTERVAL = 5000;

// ç”Ÿæˆéšæœºæ€ªç‰©
function spawnMonster() {
    if (activeMonsters.length >= MAX_MONSTERS) return;
    
    // éšæœºé€‰æ‹©æ€ªç‰©ç±»å‹
    const monsterType = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
    
    // åœ¨ç©å®¶å‘¨å›´éšæœºä½ç½®ç”Ÿæˆï¼Œä½†åœ¨å±å¹•è¾¹ç¼˜å¤–
    const angle = Math.random() * Math.PI * 2;
    const distance = canvas.width * 0.7; // åœ¨å±å¹•å¤–ç”Ÿæˆ
    const spawnX = player.x + Math.cos(angle) * distance;
    const spawnY = player.y + Math.sin(angle) * distance;
    
    // æ ¹æ®æ¦‚ç‡å†³å®šé—®é¢˜æ•°é‡
    let questionCount;
    const rand = Math.random();
    if (rand < 0.7) { // 70%æ¦‚ç‡ - 1ä¸ªé—®é¢˜
        questionCount = 1;
    } else if (rand < 0.9) { // 20%æ¦‚ç‡ - 2ä¸ªé—®é¢˜
        questionCount = 2;
    } else { // 10%æ¦‚ç‡ - 3ä¸ªé—®é¢˜
        questionCount = 3;
    }
    
    // æ ¹æ®é—®é¢˜æ•°é‡è°ƒæ•´å¥–åŠ±
    let adjustedReward = monsterType.reward;
    if (questionCount === 2) {
        adjustedReward = Math.floor(adjustedReward * 1.5);
    } else if (questionCount === 3) {
        adjustedReward = Math.floor(adjustedReward * 2);
    }
    
    // ä»é—®é¢˜åº“ä¸­éšæœºé€‰æ‹©æŒ‡å®šæ•°é‡çš„ä¸åŒé—®é¢˜
    const selectedQuestions = [];
    const availableQuestions = [...blockchainQuestions];
    
    for (let i = 0; i < questionCount && availableQuestions.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
        selectedQuestions.push(availableQuestions.splice(randomIndex, 1)[0]);
    }
    
    // åˆ›å»ºæ€ªç‰©å¯¹è±¡
    const monster = {
        id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
        x: spawnX,
        y: spawnY,
        targetX: player.x,
        targetY: player.y,
        type: monsterType.type,
        color: monsterType.color,
        health: monsterType.health,
        size: monsterType.size,
        speed: 1 + Math.random() * 2, // 1-3çš„éšæœºé€Ÿåº¦
        reward: adjustedReward,
        questions: selectedQuestions,
        currentQuestionIndex: 0,
        defeated: false
    };
    
    activeMonsters.push(monster);
}

/**
 * Player Class
 */
class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.size = 20;
        this.speed = 7;
        this.dragSpeed = 10;
        this.color = '#fff';
        this.vx = 0;
        this.vy = 0;
        this.health = 100; // æ·»åŠ ç”Ÿå‘½å€¼
        this.lastHealth = 100;
    }

    update() {
        // ç§»åŠ¨æ§åˆ¶
        let moveX = 0;
        let moveY = 0;
        
        // é”®ç›˜æ§åˆ¶
        if (keys['w'] || keys['arrowup']) moveY -= this.speed;
        if (keys['s'] || keys['arrowdown']) moveY += this.speed;
        if (keys['a'] || keys['arrowleft']) moveX -= this.speed;
        if (keys['d'] || keys['arrowright']) moveX += this.speed;
        
        // æ‹–æ‹½æ§åˆ¶ï¼ˆè§¦æ‘¸å±å’Œé¼ æ ‡ï¼‰
        if (isDragging) {
            // ä½¿ç”¨æ‹–æ‹½åç§»é‡ï¼Œä½†é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼Œå¹¶åè½¬æ–¹å‘ä½¿æ§åˆ¶æ›´ç›´è§‚
            const dragMag = Math.sqrt(dragOffsetX * dragOffsetX + dragOffsetY * dragOffsetY);
            if (dragMag > 0) {
                moveX -= (dragOffsetX / dragMag) * this.dragSpeed;
                moveY -= (dragOffsetY / dragMag) * this.dragSpeed;
            }
        }
        
        // è§„èŒƒåŒ–å‘é‡ä»¥ä¿æŒå¯¹è§’çº¿ç§»åŠ¨é€Ÿåº¦ä¸€è‡´
        const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
        if (magnitude > 0) {
            moveX = (moveX / magnitude) * Math.max(this.speed, magnitude * 0.1);
            moveY = (moveY / magnitude) * Math.max(this.speed, magnitude * 0.1);
        }
        
        // æ›´æ–°ä½ç½®
        this.x += moveX;
        this.y += moveY;

        // ç§»é™¤è¾¹ç•Œæ£€æŸ¥ï¼Œå®ç°å¼€æ”¾å¼åœ°å›¾
    }

    draw() {
        ctx.save();
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
        
        // Direction indicator (triangle)
        ctx.fillStyle = '#00ff41';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 15);
        ctx.lineTo(this.x - 5, this.y - 5);
        ctx.lineTo(this.x + 5, this.y - 5);
        ctx.fill();
        ctx.restore();
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
        
        // æ›´æ–°UIæ˜¾ç¤º
        updateHealthBar();
        
        return this.health <= 0;
    }
}

const player = new Player();

// æ›´æ–°ç”Ÿå‘½å€¼UI
function updateHealthBar() {
    const healthEl = document.getElementById('health');
    const healthFill = document.getElementById('health-fill');
    healthEl.innerText = player.health;
    healthFill.style.width = `${player.health}%`;
    
    // æ ¹æ®ç”Ÿå‘½å€¼æ”¹å˜é¢œè‰²
    if (player.health > 60) {
        healthFill.style.backgroundColor = '#ff0000';
    } else if (player.health > 30) {
        healthFill.style.backgroundColor = '#ffff00';
    } else {
        healthFill.style.backgroundColor = '#ff0000';
    }
}

/**
 * Input Handling
 */
const keys = {};
// è§¦æ‘¸å±æ§åˆ¶
let isDragging = false;
let lastTouchX = 0;
let lastTouchY = 0;
let dragOffsetX = 0;
let dragOffsetY = 0;

window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'e' || e.key === 'E') tryInteract();
    if(e.key === 'm' || e.key === 'M') startMining();
});
window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// è§¦æ‘¸å±è§¦æ‘¸å¼€å§‹äº‹ä»¶
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
    
    const touch = e.touches[0];
    isDragging = true;
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    dragOffsetX = 0;
    dragOffsetY = 0;
}, { passive: false });

// è§¦æ‘¸å±è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
    
    if (isDragging && gameState === 'PLAY') {
        const touch = e.touches[0];
        const deltaX = touch.clientX - lastTouchX;
        const deltaY = touch.clientY - lastTouchY;
        
        // æ›´æ–°ç©å®¶ç§»åŠ¨æ–¹å‘ï¼ˆåå‘ï¼Œå› ä¸ºæ‹–æ‹½æ˜¯è®©èƒŒæ™¯ç§»åŠ¨ï¼Œç›¸å½“äºç©å®¶å‘ç›¸åæ–¹å‘ç§»åŠ¨ï¼‰
        dragOffsetX = -deltaX;
        dragOffsetY = -deltaY;
        
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
    }
}, { passive: false });

// è§¦æ‘¸å±è§¦æ‘¸ç»“æŸäº‹ä»¶
canvas.addEventListener('touchend', () => {
    isDragging = false;
    dragOffsetX = 0;
    dragOffsetY = 0;
});

// é¼ æ ‡æ‹–æ‹½æ”¯æŒ
canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) { // å·¦é”®
        isDragging = true;
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
        dragOffsetX = 0;
        dragOffsetY = 0;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (isDragging && gameState === 'PLAY') {
        const deltaX = e.clientX - lastTouchX;
        const deltaY = e.clientY - lastTouchY;
        
        // æ›´æ–°ç©å®¶ç§»åŠ¨æ–¹å‘ï¼ˆåå‘ï¼‰
        dragOffsetX = -deltaX;
        dragOffsetY = -deltaY;
        
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
    }
});

window.addEventListener('mouseup', () => {
    isDragging = false;
    dragOffsetX = 0;
    dragOffsetY = 0;
});

// ç‚¹å‡»æ”»å‡»æŒ‰é’®äº‹ä»¶
const interactionBtn = document.getElementById('interaction-hint');
interactionBtn.addEventListener('click', () => {
    if (gameState === 'PLAY' && currentMonster) {
        tryInteract();
    }
});

function handleInput() {
    if(gameState !== 'PLAY') return;

    player.vx = 0;
    player.vy = 0;

    if(keys['w'] || keys['arrowup']) player.vy = -player.speed;
    if(keys['s'] || keys['arrowdown']) player.vy = player.speed;
    if(keys['a'] || keys['arrowleft']) player.vx = -player.speed;
    if(keys['d'] || keys['arrowright']) player.vx = player.speed;
}

/**
 * Game Logic
 */

// æ›´æ–°æ€ªç‰©ä½ç½®å’Œè¡Œä¸º
function updateMonsters() {
    activeMonsters = activeMonsters.filter(monster => !monster.defeated);
    
    activeMonsters.forEach(monster => {
        // å¦‚æœç©å®¶åœ¨ç¨³å®šåŒºå†…ï¼Œæ€ªç‰©ä¸è¿½è¸ªç©å®¶ï¼Œè€Œæ˜¯åœ¨ç¨³å®šåŒºå¤–å·¡é€»
        let targetX, targetY;
        if (isInStableZone(player.x, player.y)) {
            // æ‰¾åˆ°æœ€è¿‘çš„ç¨³å®šåŒºè¾¹ç•Œç‚¹ä½œä¸ºç›®æ ‡
            let closestDistance = Infinity;
            let closestPoint = { x: player.x, y: player.y };
            
            stableZones.forEach(zone => {
                const dx = player.x - zone.x;
                const dy = player.y - zone.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance > 0) {
                    // è®¡ç®—ç¨³å®šåŒºè¾¹ç•Œä¸Šçš„ç‚¹
                    const boundaryX = zone.x + (dx / distance) * zone.radius;
                    const boundaryY = zone.y + (dy / distance) * zone.radius;
                    
                    // æ£€æŸ¥è¿™ä¸ªç‚¹æ˜¯å¦æ¯”å½“å‰æœ€è¿‘ç‚¹æ›´è¿‘
                    const toMonsterDist = Math.sqrt(
                        Math.pow(boundaryX - monster.x, 2) + 
                        Math.pow(boundaryY - monster.y, 2)
                    );
                    
                    if (toMonsterDist < closestDistance) {
                        closestDistance = toMonsterDist;
                        closestPoint = { x: boundaryX, y: boundaryY };
                    }
                }
            });
            
            targetX = closestPoint.x;
            targetY = closestPoint.y;
        } else {
            // ç©å®¶ä¸åœ¨ç¨³å®šåŒºï¼Œæ­£å¸¸è¿½è¸ª
            targetX = player.x;
            targetY = player.y;
        }
        
        // è®¡ç®—ç§»åŠ¨æ–¹å‘
        const dx = targetX - monster.x;
        const dy = targetY - monster.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0) {
            // è®¡ç®—æ–°ä½ç½®
            let newX = monster.x + (dx / dist) * monster.speed;
            let newY = monster.y + (dy / dist) * monster.speed;
            
            // æ£€æŸ¥æ–°ä½ç½®æ˜¯å¦åœ¨ç¨³å®šåŒºå†…ï¼Œå¦‚æœæ˜¯åˆ™ä¸ç§»åŠ¨
            if (!isInStableZone(newX, newY)) {
                monster.x = newX;
                monster.y = newY;
            }
        }
    });
}

// ç»˜åˆ¶æŒ–çŸ¿ç‚¹
function drawMiningSites() {
    miningSites.forEach(site => {
        // è®¡ç®—å±å¹•ä¸Šçš„ä½ç½®
        const screenX = site.x - player.x + canvas.width / 2;
        const screenY = site.y - player.y + canvas.height / 2;
        
        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        const maxRenderDistance = Math.max(canvas.width, canvas.height) / 2 + site.radius;
        const distanceToCenter = Math.sqrt(screenX*screenX + screenY*screenY);
        
        if (distanceToCenter < maxRenderDistance) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(screenX, screenY, site.radius, 0, Math.PI * 2);
            
            // æ ¹æ®æ˜¯å¦æ´»è·ƒå’Œç©å®¶æ˜¯å¦åœ¨å…¶ä¸­æ”¹å˜é¢œè‰²
            if (!site.active) {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.2)';
                ctx.strokeStyle = '#666';
            } else if (isInMiningSite(player.x, player.y)) {
                ctx.fillStyle = 'rgba(255, 152, 0, 0.4)';
                ctx.strokeStyle = '#ff9800';
            } else {
                ctx.fillStyle = 'rgba(255, 152, 0, 0.2)';
                ctx.strokeStyle = '#ff9800';
            }
            
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // æ·»åŠ æŒ–çŸ¿å›¾æ ‡
            ctx.fillStyle = site.active ? '#ff9800' : '#666';
            ctx.font = '24px VT323';
            ctx.textAlign = 'center';
            ctx.fillText('â›ï¸', screenX, screenY + 8);
            
            // å¦‚æœæ´»è·ƒï¼Œæ·»åŠ è„‰å†²æ•ˆæœ
            if (site.active) {
                ctx.strokeStyle = 'rgba(255, 152, 0, 0.6)';
                ctx.lineWidth = 1;
                const pulseRadius = site.radius * (1 + 0.2 * Math.sin(Date.now() * 0.002));
                ctx.beginPath();
                ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.restore();
        }
    });
}

// ç»˜åˆ¶NFT
function drawNFTs() {
    activeNFTs.forEach(nft => {
        if (nft.collected) return;
        
        // è®¡ç®—å±å¹•ä½ç½®
        const screenX = nft.x - player.x + canvas.width / 2;
        const screenY = nft.y - player.y + canvas.height / 2;
        
        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        if (screenX > -nft.size * 2 && screenX < canvas.width + nft.size * 2 &&
            screenY > -nft.size * 2 && screenY < canvas.height + nft.size * 2) {
            
            ctx.save();
            ctx.translate(screenX, screenY);
            ctx.rotate(nft.rotation);
            
            // ç»˜åˆ¶NFTè¾¹æ¡†
            ctx.strokeStyle = nft.type.color;
            ctx.lineWidth = 2;
            ctx.strokeRect(-nft.size/2, -nft.size/2, nft.size, nft.size);
            
            // æ ¹æ®ç¨€æœ‰åº¦æ·»åŠ å‘å…‰æ•ˆæœ
            if (nft.type.rarity === 'uncommon') {
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#4caf50';
            } else if (nft.type.rarity === 'rare') {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#2196f3';
            } else if (nft.type.rarity === 'epic') {
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#9c27b0';
            } else if (nft.type.rarity === 'legendary') {
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ffeb3b';
            }
            
            // å¡«å……NFTèƒŒæ™¯
            ctx.fillStyle = nft.type.color;
            ctx.fillRect(-nft.size/2, -nft.size/2, nft.size, nft.size);
            
            // é‡ç½®é˜´å½±
            ctx.shadowBlur = 0;
            
            // æ·»åŠ NFTå›¾æ ‡æˆ–æ–‡å­—
            ctx.fillStyle = '#fff';
            ctx.font = '14px VT323';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('NFT', 0, 0);
            
            // æ·»åŠ ç¨€æœ‰åº¦æ ‡è®°
            let rarityMark = '';
            if (nft.type.rarity === 'uncommon') rarityMark = 'â—†';
            else if (nft.type.rarity === 'rare') rarityMark = 'â—†â—†';
            else if (nft.type.rarity === 'epic') rarityMark = 'â—†â—†â—†';
            else if (nft.type.rarity === 'legendary') rarityMark = 'â˜…';
            
            if (rarityMark) {
                ctx.fillStyle = nft.type.rarity === 'legendary' ? '#ffeb3b' : '#fff';
                ctx.font = '10px VT323';
                ctx.fillText(rarityMark, 0, -nft.size/2 - 5);
            }
            
            ctx.restore();
            
            // æ·»åŠ å¸å¼•ç©å®¶çš„è„‰åŠ¨æ•ˆæœ
            const pulseRadius = nft.size * (1 + 0.1 * Math.sin(Date.now() * 0.005));
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(${hexToRgb(nft.type.color)}, 0.5)`;
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    });
}

// è¾…åŠ©å‡½æ•°ï¼šåå…­è¿›åˆ¶é¢œè‰²è½¬RGB
function hexToRgb(hex) {
    // ç§»é™¤#å·
    hex = hex.replace('#', '');
    
    // è§£æRGBå€¼
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return `${r}, ${g}, ${b}`;
}

// æ£€æŸ¥ç©å®¶ä¸æ€ªç‰©çš„ç¢°æ’
function checkCollisions() {
    // å¦‚æœæ­£åœ¨æˆ˜æ–—ä¸­ï¼Œä¸æ˜¾ç¤ºäº¤äº’æç¤º
    if (gameState === 'QUIZ') {
        hintEl.style.display = 'none';
        return;
    }
    
    let nearAny = false;
    currentMonster = null;
    
    // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨ç¨³å®šåŒºå†…
    const playerInStableZone = isInStableZone(player.x, player.y);
    
    activeMonsters.forEach(monster => {
        if(monster.defeated) return;
        
        const dx = player.x - monster.x;
        const dy = player.y - monster.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œæ€ªç‰©æ”»å‡»ç©å®¶
        // ä½†åªæœ‰å½“ç©å®¶ä¸åœ¨ç¨³å®šåŒºæ—¶æ‰ä¼šå—åˆ°ä¼¤å®³
        if (dist < (player.size/2 + monster.size/2) && !playerInStableZone) {
            // æ€ªç‰©æ”»å‡»ç©å®¶
            if (Math.random() < 0.1) { // 10%çš„æ¦‚ç‡æ”»å‡»
                player.takeDamage(5);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }
        
        // äº¤äº’åŠå¾„
        // ç©å®¶åœ¨ç¨³å®šåŒºæ—¶ä¹Ÿå¯ä»¥ä¸æ€ªç‰©äº¤äº’ï¼Œä½†ä¸ä¼šå—åˆ°ä¼¤å®³
        if (dist < 80) {
            nearAny = true;
            currentMonster = monster;
        }
    });
    
    if (nearAny && gameState === 'PLAY') {
        hintEl.style.display = 'block';
        hintEl.style.opacity = '1';
        // æ·»åŠ è„‰åŠ¨åŠ¨ç”»æç¤º
        hintEl.style.animation = 'pulse 2s infinite';
    } else {
        hintEl.style.display = 'none';
        hintEl.style.opacity = '0';
        hintEl.style.animation = 'none';
    }
}

// æ¸¸æˆç»“æŸ
function gameOver() {
    gameState = 'GAME_OVER';
    alert(`ğŸ’€ æ¸¸æˆç»“æŸï¼ä½ è¢«åŒºå—é“¾æ€ªç‰©å‡»è´¥äº†ï¼\næœ€ç»ˆå¾—åˆ†: ${score} ETH\nå‡»è´¥çš„æ€ªç‰©: ${defeatedCount} ä¸ª`);
    location.reload();
}

function tryInteract() {
    if(gameState === 'PLAY' && currentMonster) {
        // å¼€å§‹ä¸æ€ªç‰©çš„æˆ˜æ–—é—®ç­”
        startMonsterBattle(currentMonster);
    }
}

function startMonsterBattle(monster) {
    currentMonster = monster;
    monster.currentQuestionIndex = 0;
    askMonsterQuestion();
}

// èƒ½é‡é“å…·ç±»
class EnergyPotion {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.color = '#FFD700'; // é‡‘è‰²
        this.pulse = 0; // ç”¨äºè„‰å†²åŠ¨ç”»æ•ˆæœ
        this.pulseSpeed = 0.05;
        this.healthRestore = 20; // æ¢å¤20ç‚¹ç”Ÿå‘½å€¼
    }
    
    update() {
        // æ›´æ–°è„‰å†²åŠ¨ç”»
        this.pulse += this.pulseSpeed;
        if (this.pulse > Math.PI * 2) {
            this.pulse = 0;
        }
    }
    
    draw(ctx) {
        // è®¡ç®—å±å¹•ä¸Šçš„ä½ç½®ï¼ˆè€ƒè™‘ä¸–ç•Œåç§»ï¼‰
        const screenX = this.x - player.x + canvas.width / 2;
        const screenY = this.y - player.y + canvas.height / 2;
        
        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        if (screenX > -this.radius * 2 && screenX < canvas.width + this.radius * 2 &&
            screenY > -this.radius * 2 && screenY < canvas.height + this.radius * 2) {
            
            // ç»˜åˆ¶è„‰å†²æ•ˆæœ
            const pulseRadius = this.radius * (1 + 0.3 * Math.sin(this.pulse));
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 215, 0, ${0.2 * (1 + Math.sin(this.pulse))})`;
            ctx.fill();
            
            // ç»˜åˆ¶èƒ½é‡é“å…·ä¸»ä½“
            ctx.beginPath();
            ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // ç»˜åˆ¶åå­—ç¬¦å·
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX - 8, screenY);
            ctx.lineTo(screenX + 8, screenY);
            ctx.moveTo(screenX, screenY - 8);
            ctx.lineTo(screenX, screenY + 8);
            ctx.stroke();
        }
    }
    
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < this.radius + player.size/2;
    }
}

// æ´»è·ƒçš„èƒ½é‡é“å…·æ•°ç»„
let activePotions = [];
// èƒ½é‡é“å…·ç”Ÿæˆè®¾ç½®
//const maxEnergyPotions = 10;
//const energySpawnChance = 0.005; // æ¯å¸§ç”Ÿæˆèƒ½é‡é“å…·çš„æ¦‚ç‡
const energySpawnInterval = 15000; // å›ºå®šé—´éš”ç”Ÿæˆ(æ¯«ç§’)
let energySpawnTimer = null;

function askMonsterQuestion() {
    if (!currentMonster || currentMonster.currentQuestionIndex >= currentMonster.questions.length) {
        return;
    }
    
    gameState = 'QUIZ';
    hintEl.style.display = 'none';
    modal.style.display = 'block';
    
    const currentQuestion = currentMonster.questions[currentMonster.currentQuestionIndex];
    modalTitle.innerText = `${currentMonster.type} - é—®é¢˜ ${currentMonster.currentQuestionIndex + 1}/${currentMonster.questions.length}`;
    modalText.innerText = currentQuestion.question;
    modalOptions.innerHTML = '';
    
    // æ‰“ä¹±é€‰é¡¹é¡ºåº
    const shuffledOptions = shuffleArray([...currentQuestion.options]);
    
    shuffledOptions.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.innerText = opt.text;
        btn.onclick = () => handleAnswer(opt.correct);
        modalOptions.appendChild(btn);
    });
}

function handleAnswer(isCorrect) {
    if (isCorrect) {
        modalText.innerText = "âœ… å›ç­”æ­£ç¡®ï¼å¯¹æ€ªç‰©é€ æˆä¼¤å®³ï¼";
        
        // å¯¹æ€ªç‰©é€ æˆä¼¤å®³
        currentMonster.health -= 30; // æ¯ä¸ªæ­£ç¡®ç­”æ¡ˆé€ æˆ30ç‚¹ä¼¤å®³
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªé—®é¢˜
        const isLastQuestion = currentMonster.currentQuestionIndex === currentMonster.questions.length - 1;
        
        if (currentMonster.health <= 0) {
            // æ€ªç‰©è¢«å‡»è´¥
            modalText.innerText = "ğŸ’¥ æ€ªç‰©è¢«å‡»è´¥ï¼è·å¾—å¥–åŠ±ï¼";
            // ç¡®ä¿currentMonsterå¯¹è±¡è¢«å¼•ç”¨ï¼Œé¿å…åœ¨finishBattleä¸­ä¸¢å¤±
            const defeatedMonster = currentMonster;
            modalOptions.innerHTML = `<button class="option-btn" onclick="finishBattle(true)">ç»§ç»­æ¢ç´¢</button>`;
        } else if (isLastQuestion) {
            // æœ€åä¸€ä¸ªé—®é¢˜ä½†æ€ªç‰©æœªè¢«å‡»è´¥ï¼Œä»ç„¶ç»“æŸæˆ˜æ–—
            modalOptions.innerHTML = '<button class="option-btn" onclick="finishBattle(false)">ç»§ç»­æ¢ç´¢</button>';
        } else {
            // ä¸æ˜¯æœ€åä¸€ä¸ªé—®é¢˜ä¸”æ€ªç‰©æœªè¢«å‡»è´¥ï¼Œç»§ç»­æˆ˜æ–—
            modalOptions.innerHTML = '<button class="option-btn" onclick="continueBattle()">ç»§ç»­æ”»å‡»</button>';
        }
    } else {
        modalText.innerText = "âŒ å›ç­”é”™è¯¯ï¼å—åˆ°åå‡»ï¼";
        
        // ç©å®¶å—åˆ°ä¼¤å®³
        player.takeDamage(10);
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
        if (player.health <= 0) {
            // ä¿å­˜å½“å‰æ€ªç‰©çŠ¶æ€ç”¨äºç»“æŸæˆ˜æ–—
            const monsterToFinish = currentMonster;
            // å…ˆæ¸…é™¤modalï¼Œé¿å…æ˜¾ç¤ºä¸¤æ¬¡
            modal.style.display = 'none';
            // å…ˆç»“æŸå½“å‰æˆ˜æ–—ï¼Œå†è°ƒç”¨gameOver
            finishBattle(false);
            // è°ƒç”¨gameOver
            gameOver();
            return;
        }
        
        // å¯¹äºå›ç­”é”™è¯¯çš„æƒ…å†µï¼Œä¸å†é‡å¤åŒä¸€ä¸ªé—®é¢˜ï¼Œç›´æ¥ç»“æŸæˆ˜æ–—
        modalOptions.innerHTML = '<button class="option-btn" onclick="finishBattle(false)">ç»§ç»­æ¢ç´¢</button>';
    }
}

function continueBattle() {
    if (!currentMonster || currentMonster.defeated) {
        return; // å®‰å…¨æ£€æŸ¥ï¼Œé¿å…å¤„ç†æ— æ•ˆæ€ªç‰©
    }
    
    // è¿›å…¥ä¸‹ä¸€ä¸ªé—®é¢˜
    currentMonster.currentQuestionIndex++;
    
    // ç¡®ä¿ä¸ä¼šè¶…å‡ºé—®é¢˜èŒƒå›´
    if (currentMonster.currentQuestionIndex < currentMonster.questions.length) {
        askMonsterQuestion();
    } else {
        // æ‰€æœ‰é—®é¢˜éƒ½å·²é—®å®Œï¼Œç»“æŸæˆ˜æ–—
        finishBattle(currentMonster.health <= 0);
    }
}

function finishBattle(success) {
    // ç¡®ä¿modalè¢«éšè—
    modal.style.display = 'none';
    gameState = 'PLAY';
    
    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿currentMonsterå­˜åœ¨ä¸”æœªè¢«å¤„ç†è¿‡
    if (currentMonster) {
        if(success) {
            // å¢åŠ åˆ†æ•°å’Œå‡»è´¥è®¡æ•°
            score += currentMonster.reward;
            defeatedCount++;
            
            // æ ‡è®°æ€ªç‰©ä¸ºå·²å‡»è´¥
            currentMonster.defeated = true;
            
            // æ›´æ–°UI
            scoreEl.innerText = score;
            progressEl.innerText = defeatedCount;
            
            // éšæœºæ¢å¤ä¸€äº›ç”Ÿå‘½å€¼
            player.health = Math.min(100, player.health + Math.floor(Math.random() * 15) + 5);
            updateHealthBar();
        }
        
        // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¸…é™¤å½“å‰æ€ªç‰©å¼•ç”¨ï¼Œé¿å…é‡å¤å¤„ç†
        currentMonster = null;
    }
}

// å·¥å…·å‡½æ•°ï¼šæ‰“ä¹±æ•°ç»„é¡ºåº
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * Rendering
 */
function drawGrid() {
    ctx.strokeStyle = '#003300';
    ctx.lineWidth = 1;
    const gridSize = 50;
    
    // Moving grid effect
    const offsetX = -player.x % gridSize;
    const offsetY = -player.y % gridSize;

    for(let x = offsetX; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for(let y = offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawMonsters() {
    activeMonsters.forEach(monster => {
        if(monster.defeated) return;

        // è®¡ç®—å±å¹•ä½ç½®ï¼ˆæ‘„åƒæœºè·Ÿéšç©å®¶ï¼‰
        const screenX = (monster.x - player.x) + canvas.width / 2;
        const screenY = (monster.y - player.y) + canvas.height / 2;

        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        if(screenX > -100 && screenX < canvas.width + 100 && 
           screenY > -100 && screenY < canvas.height + 100) {
               
            ctx.save();
            
            // ç»˜åˆ¶æ€ªç‰©èº«ä½“
            ctx.fillStyle = monster.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = monster.color;
            
            // ç»˜åˆ¶æ€ªç‰©å½¢çŠ¶ï¼ˆåœ†å½¢ï¼‰
            ctx.beginPath();
            ctx.arc(screenX, screenY, monster.size/2, 0, Math.PI*2);
            ctx.fill();
            
            // ç»˜åˆ¶ç”Ÿå‘½å€¼æ¡
            const barWidth = monster.size;
            const barHeight = 5;
            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - barWidth/2, screenY - monster.size/2 - 15, barWidth, barHeight);
            
            ctx.fillStyle = monster.health > 50 ? '#00ff00' : monster.health > 25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(screenX - barWidth/2, screenY - monster.size/2 - 15, (barWidth * monster.health) / (monsterTypes.find(mt => mt.type === monster.type).health), barHeight);
            
            // æ€ªç‰©åç§°
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.font = '14px VT323';
            ctx.fillText(monster.type, screenX, screenY - monster.size/2 - 25);
            
            // é—®é¢˜æ ‡è®°
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px VT323';
            ctx.fillText("?", screenX - 2, screenY + 3);
            
            ctx.restore();
        }
    });
}

function render() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid();
    
    // ç»˜åˆ¶ç¨³å®šåŒº
    stableZones.forEach(zone => {
        // è®¡ç®—å±å¹•ä¸Šçš„ä½ç½®
        const screenX = zone.x - player.x + canvas.width / 2;
        const screenY = zone.y - player.y + canvas.height / 2;
        
        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        const maxRenderDistance = Math.max(canvas.width, canvas.height) / 2 + zone.radius;
        const distanceToCenter = Math.sqrt(screenX*screenX + screenY*screenY);
        
        if (distanceToCenter < maxRenderDistance) {
            ctx.save();
            ctx.beginPath();
            ctx.arc(screenX, screenY, zone.radius, 0, Math.PI * 2);
            ctx.fillStyle = zone.color;
            ctx.fill();
            
            // ç»˜åˆ¶ç¨³å®šåŒºè¾¹æ¡†
            ctx.strokeStyle = '#0096FF';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // æ·»åŠ ç¨³å®šå¸å›¾æ ‡æˆ–æ ‡è®°
            ctx.fillStyle = '#0096FF';
            ctx.font = '24px VT323';
            ctx.textAlign = 'center';
            ctx.fillText('USDT', screenX, screenY + 8);
            ctx.restore();
        }
    });
    
    // ç»˜åˆ¶æŒ–çŸ¿ç‚¹
    drawMiningSites();
    
    // ç»˜åˆ¶NFT
    drawNFTs();
    
    // ç»˜åˆ¶èƒ½é‡é“å…·
    energyPotions.forEach(potion => potion.draw(ctx));
    
    // ç»˜åˆ¶æ€ªç‰©ï¼ˆç›¸å¯¹äºç©å®¶çš„ä½ç½®ï¼‰
    drawMonsters();

    // ç»˜åˆ¶ç©å®¶ï¼ˆå§‹ç»ˆåœ¨å±å¹•ä¸­å¿ƒï¼‰
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    
    // Player glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ff41';
    ctx.fillStyle = '#fff';
    
    // Draw player circle - ç§»é™¤ä¸‰è§’å½¢æŒ‡ç¤ºå™¨
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
    
    // ç»˜åˆ¶é€šçŸ¥
    notifications.forEach(notification => notification.draw(ctx));
}

// é€šçŸ¥ç±»
class Notification {
    constructor(text, x, y, duration = 2000) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.duration = duration;
        this.createdAt = Date.now();
        this.opacity = 1;
        this.offset = 0;
    }
    
    update() {
        const age = Date.now() - this.createdAt;
        this.offset -= 0.5; // å‘ä¸Šç§»åŠ¨
        
        // æ·¡å‡ºæ•ˆæœ
        if (age > this.duration * 0.7) {
            this.opacity = 1 - (age - this.duration * 0.7) / (this.duration * 0.3);
        }
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.font = '20px Arial';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y + this.offset);
        ctx.restore();
    }
    
    isExpired() {
        return Date.now() - this.createdAt > this.duration;
    }
}

// é€šçŸ¥æ•°ç»„
let notifications = [];

// æ˜¾ç¤ºé€šçŸ¥
function showNotification(text) {
    const notification = new Notification(text, canvas.width / 2, canvas.height / 4);
    notifications.push(notification);
}

// èƒ½é‡é“å…·ç”Ÿæˆé…ç½®
const energySpawnChance = 0.005;
const maxEnergyPotions = 3;

// èƒ½é‡é“å…·æ•°ç»„
let energyPotions = [];

// ç”Ÿæˆèƒ½é‡é“å…·
function spawnEnergyPotion() {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    energyPotions.push(new EnergyPotion(x, y));
}

// å¤„ç†èƒ½é‡é“å…·ç¢°æ’
function handleEnergyCollision() {
    energyPotions = energyPotions.filter(potion => {
        if (potion.checkCollision(player)) {
            player.health = Math.min(100, player.health + potion.healthRestore);
            updateHealthBar();
            showNotification(`+${potion.healthRestore} ç”Ÿå‘½å€¼`);
            return false;
        }
        return true;
    });
}

/**
 * Game Loop
 */
function loop(timestamp) {
    if(gameState === 'PLAY') {
        handleInput();
        player.update();
        updateMonsters();
        checkCollisions();
        
        // æ›´æ–°NFT
        updateNFTs();
        checkNFTCollection();
        
        // æ£€æŸ¥æŒ–çŸ¿äº¤äº’
        checkMiningInteraction();
        updateMining();
        
        // æ›´æ–°èƒ½é‡é“å…·
        energyPotions.forEach(potion => potion.update());
        
        // å¤„ç†èƒ½é‡é“å…·ç¢°æ’
        handleEnergyCollision();
        
        // æ›´æ–°é€šçŸ¥
        notifications.forEach(notification => notification.update());
        notifications = notifications.filter(notification => !notification.isExpired());
        
        // æ§åˆ¶æ€ªç‰©ç”Ÿæˆ
        if (!lastSpawnTime) lastSpawnTime = timestamp;
        if (timestamp - lastSpawnTime > SPAWN_INTERVAL) {
            spawnMonster();
            lastSpawnTime = timestamp;
        }
        
        // éšæœºç”ŸæˆNFT
        if (Math.random() < 0.002) { // æ¯å¸§çº¦0.2%æ¦‚ç‡ç”ŸæˆNFT
            spawnNFT();
        }
        
        // èƒ½é‡é“å…·ç”±å®šæ—¶å™¨ç”Ÿæˆï¼Œä¸å†éœ€è¦æ¯å¸§æ£€æŸ¥
    }
    render();
    requestAnimationFrame(loop);
}

// å…¨å±€å˜é‡ï¼Œä½¿closeModalç­‰å‡½æ•°åœ¨windowä½œç”¨åŸŸä¸­å¯ç”¨
window.closeModal = finishBattle;

// Start Button
document.getElementById('start-btn').addEventListener('click', () => {
    startScreen.classList.add('hidden');
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (energySpawnTimer) {
        clearInterval(energySpawnTimer);
    }
    
    // é‡ç½®æ¸¸æˆçŠ¶æ€
    playerNFTs = [];
    activeNFTs = [];
    score = 0;
    defeatedCount = 0;
    isMining = false;
    miningProgress = 0;
    currentMiningSite = null;
    scoreEl.innerText = score;
    progressEl.innerText = defeatedCount;
    
    // åˆå§‹åŒ–NFTæ”¶è—UI
    updateNFTCollectionUI();
    
    // è®¾ç½®ç©å®¶åˆå§‹ä½ç½®
    player.x = 0;
    player.y = 0;
    
    // åˆå§‹åŒ–ç”Ÿå‘½å€¼æ˜¾ç¤º
    updateHealthBar();
    
    // åˆå§‹ç”Ÿæˆå‡ ä¸ªæ€ªç‰©
    for (let i = 0; i < 3; i++) {
        setTimeout(spawnMonster, i * 1000);
    }
    
    // ç”Ÿæˆåˆå§‹èƒ½é‡é“å…·
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            if (gameState === 'PLAY' && energyPotions.length < maxEnergyPotions) {
                spawnEnergyPotion();
            }
        }, i * 2000);
    }
    
    // ç”Ÿæˆåˆå§‹NFT
    for (let i = 0; i < 2; i++) {
        setTimeout(() => {
            if (gameState === 'PLAY') {
                spawnNFT();
            }
        }, i * 3000 + 1000);
    }
    
    // é‡æ–°æ¿€æ´»æ‰€æœ‰æŒ–çŸ¿ç‚¹
    miningSites.forEach(site => {
        site.active = true;
    });
    
    // è®¾ç½®èƒ½é‡é“å…·å®šæ—¶ç”Ÿæˆå™¨
    energySpawnTimer = setInterval(() => {
        if (gameState === 'PLAY' && energyPotions.length < maxEnergyPotions) {
            spawnEnergyPotion();
        }
    }, energySpawnInterval);

    gameState = 'PLAY';
    
    requestAnimationFrame(loop);
});

</script>
</body>
</html>