<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 æ¢ç´¢è€…ï¼šåˆ›ä¸–åŒºå—ä¹‹æ—…</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #00ff41;
            font-family: 'VT323', monospace;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.1);
            border: 2px solid #333;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff41;
        }

        h1 { margin: 0; font-size: 2em; }
        p { margin: 5px 0; font-size: 1.2em; opacity: 0.8; }

        /* Dialogue / Quiz Modal */
        #modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff41;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
            z-index: 10;
            text-align: center;
        }

        #modal h2 { margin-top: 0; color: #fff; }
        
        .option-btn {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            background: #003300;
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.2em;
            transition: 0.2s;
        }

        .option-btn:hover {
            background: #00ff41;
            color: #000;
        }

        #interaction-hint {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            background: #000;
            padding: 10px 20px;
            border: 1px solid #fff;
            display: none;
            font-size: 1.5em;
            animation: bounce 1s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 2em;
            background: #00ff41;
            border: none;
            cursor: pointer;
            font-family: 'VT323', monospace;
            margin-top: 20px;
        }
        
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <h1>WEB3 æ¢ç´¢è€…</h1>
        <p>GASä½™é¢ (åˆ†æ•°): <span id="score">0</span> ETH</p>
        <p>å·²æ”¶é›†åŒºå—: <span id="progress">0</span> / 4</p>
        <p style="font-size: 0.8em; color: #888;">æ§åˆ¶: WASD æˆ– æ–¹å‘é”®ç§»åŠ¨ | E é”®äº¤äº’</p>
    </div>

    <div id="interaction-hint">æŒ‰ [E] è¿æ¥èŠ‚ç‚¹</div>

    <div id="modal">
        <h2 id="modal-title">èŠ‚ç‚¹æé—®</h2>
        <p id="modal-text">é—®é¢˜å†…å®¹...</p>
        <div id="modal-options"></div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 4em; text-shadow: 0 0 20px #00ff41;">WEB3 UNIVERSE</h1>
        <p>é€šè¿‡å›ç­”é—®é¢˜æ”¶é›†åˆ›ä¸–åŒºå—ï¼Œæˆä¸ºå»ä¸­å¿ƒåŒ–å¤§å¸ˆã€‚</p>
        <button id="start-btn">è¿æ¥ä¸»ç½‘ (å¼€å§‹æ¸¸æˆ)</button>
    </div>
</div>

<script>
/**
 * Game Configuration & State
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const progressEl = document.getElementById('progress');
const hintEl = document.getElementById('interaction-hint');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalOptions = document.getElementById('modal-options');
const startScreen = document.getElementById('start-screen');

let gameState = 'START'; // START, PLAY, QUIZ, WIN
let score = 0;
let collectedCount = 0;

// Resize canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/**
 * Game Data (The Knowledge Base)
 */
const npcsData = [
    {
        id: 1, x: 0, y: 0, // positions will be set relative to center
        color: '#ff0055', 
        name: 'çŸ¿å·¥èŠ‚ç‚¹ (PoW)',
        cleared: false,
        question: "åœ¨åŒºå—é“¾ä¸­ï¼Œ'å»ä¸­å¿ƒåŒ–'æ„å‘³ç€ä»€ä¹ˆï¼Ÿ",
        options: [
            { text: "æ•°æ®å­˜å‚¨åœ¨è°·æ­Œçš„æœåŠ¡å™¨ä¸Š", correct: false },
            { text: "æ²¡æœ‰å•ä¸€çš„æ§åˆ¶æœºæ„ï¼ŒæƒåŠ›ä¸‹æ”¾", correct: true },
            { text: "æ¯ä¸ªäººéƒ½å¿…é¡»ä½åœ¨åŒä¸€ä¸ªåŸå¸‚", correct: false }
        ],
        reward: 10
    },
    {
        id: 2, x: 0, y: 0,
        color: '#00ccff',
        name: 'DeFi äº¤æ˜“å‘˜',
        cleared: false,
        question: "å¦‚æœä½ ä¸¢å¤±äº†ä½ çš„'ç§é’¥'ï¼ˆPrivate Keyï¼‰ï¼Œä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿ",
        options: [
            { text: "å¯ä»¥æ‰¾å®¢æœé‡ç½®å¯†ç ", correct: false },
            { text: "æ²¡æœ‰ä»»ä½•å½±å“", correct: false },
            { text: "ä½ å°†æ°¸ä¹…å¤±å»å¯¹é’±åŒ…èµ„äº§çš„æ§åˆ¶æƒ", correct: true }
        ],
        reward: 50
    },
    {
        id: 3, x: 0, y: 0,
        color: '#ffff00',
        name: 'NFT è‰ºæœ¯å®¶',
        cleared: false,
        question: "NFT (éåŒè´¨åŒ–ä»£å¸) çš„ä¸»è¦ç‰¹å¾æ˜¯ï¼Ÿ",
        options: [
            { text: "æ¯ä¸€ä¸ªéƒ½æ˜¯ç‹¬ä¸€æ— äºŒä¸”ä¸å¯åˆ†å‰²çš„", correct: true },
            { text: "å®ƒä»¬éƒ½å¯ä»¥äº’ç›¸ç­‰ä»·äº¤æ¢ï¼ˆåƒæ¯”ç‰¹å¸ä¸€æ ·ï¼‰", correct: false },
            { text: "å®ƒä»¬åªèƒ½ç”¨æ¥ä¹°å–å›¾ç‰‡", correct: false }
        ],
        reward: 20
    },
    {
        id: 4, x: 0, y: 0,
        color: '#9d00ff',
        name: 'DAO æ²»ç†è€…',
        cleared: false,
        question: "æ™ºèƒ½åˆçº¦ï¼ˆSmart Contractï¼‰æ˜¯ä»€ä¹ˆï¼Ÿ",
        options: [
            { text: "ä¸€ä»½éå¸¸èªæ˜çš„æ³•å¾‹çº¸è´¨åˆåŒ", correct: false },
            { text: "éƒ¨ç½²åœ¨åŒºå—é“¾ä¸Šè‡ªåŠ¨æ‰§è¡Œçš„ä»£ç åè®®", correct: true },
            { text: "äººå·¥æ™ºèƒ½èŠå¤©æœºå™¨äºº", correct: false }
        ],
        reward: 30
    }
];

// Position NPCs around the map
const mapRadius = 400;
npcsData.forEach((npc, index) => {
    const angle = (index / npcsData.length) * Math.PI * 2;
    npc.x = Math.cos(angle) * mapRadius + canvas.width / 2;
    npc.y = Math.sin(angle) * mapRadius + canvas.height / 2;
});

/**
 * Player Class
 */
class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.size = 20;
        this.speed = 5;
        this.color = '#fff';
        this.vx = 0;
        this.vy = 0;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // Boundary checks
        if(this.x < 0) this.x = 0;
        if(this.x > canvas.width) this.x = canvas.width;
        if(this.y < 0) this.y = 0;
        if(this.y > canvas.height) this.y = canvas.height;
    }

    draw() {
        ctx.save();
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
        
        // Direction indicator (triangle)
        ctx.fillStyle = '#00ff41';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 15);
        ctx.lineTo(this.x - 5, this.y - 5);
        ctx.lineTo(this.x + 5, this.y - 5);
        ctx.fill();
        ctx.restore();
    }
}

const player = new Player();

/**
 * Input Handling
 */
const keys = {};
window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'e' || e.key === 'E') tryInteract();
});
window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

function handleInput() {
    if(gameState !== 'PLAY') return;

    player.vx = 0;
    player.vy = 0;

    if(keys['w'] || keys['arrowup']) player.vy = -player.speed;
    if(keys['s'] || keys['arrowdown']) player.vy = player.speed;
    if(keys['a'] || keys['arrowleft']) player.vx = -player.speed;
    if(keys['d'] || keys['arrowright']) player.vx = player.speed;
}

/**
 * Game Logic
 */
let activeNPC = null;

function checkCollisions() {
    let nearAny = false;
    activeNPC = null;

    npcsData.forEach(npc => {
        if(npc.cleared) return;

        const dx = player.x - npc.x;
        const dy = player.y - npc.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if(dist < 60) { // Interaction radius
            nearAny = true;
            activeNPC = npc;
        }
    });

    if(nearAny) {
        hintEl.style.display = 'block';
    } else {
        hintEl.style.display = 'none';
    }
}

function tryInteract() {
    if(gameState === 'PLAY' && activeNPC) {
        openQuiz(activeNPC);
    }
}

function openQuiz(npc) {
    gameState = 'QUIZ';
    hintEl.style.display = 'none';
    modal.style.display = 'block';
    modalTitle.innerText = npc.name;
    modalText.innerText = npc.question;
    modalOptions.innerHTML = '';

    // Shuffle options slightly or keep fixed - sticking to fixed for simplicity
    npc.options.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.innerText = opt.text;
        btn.onclick = () => handleAnswer(npc, opt.correct);
        modalOptions.appendChild(btn);
    });
}

function handleAnswer(npc, isCorrect) {
    if(isCorrect) {
        modalText.innerText = "âœ… å›ç­”æ­£ç¡®ï¼æ™ºèƒ½åˆçº¦æ‰§è¡ŒæˆåŠŸï¼Œå¥–åŠ±å·²å‘æ”¾ã€‚";
        modalOptions.innerHTML = '<button class="option-btn" onclick="closeModal(true)">ç»§ç»­æ¢ç´¢</button>';
    } else {
        modalText.innerText = "âŒ äº¤æ˜“å¤±è´¥ (Gasè€—å°½)ã€‚è¯·é‡è¯•ã€‚";
        // Penalty? Maybe not for learning game.
    }
}

function closeModal(success) {
    modal.style.display = 'none';
    gameState = 'PLAY';
    
    if(success && activeNPC) {
        score += activeNPC.reward;
        collectedCount++;
        activeNPC.cleared = true;
        activeNPC = null;
        
        scoreEl.innerText = score;
        progressEl.innerText = collectedCount;

        checkWinCondition();
    }
}

function checkWinCondition() {
    if(collectedCount === npcsData.length) {
        setTimeout(() => {
            alert(`ğŸ‰ æ­å–œï¼ä½ å·²ç»å®Œæˆäº†æ‰€æœ‰ Web3 æŒ‘æˆ˜ï¼\næœ€ç»ˆ GAS ä½™é¢: ${score} ETH`);
            location.reload();
        }, 500);
    }
}

/**
 * Rendering
 */
function drawGrid() {
    ctx.strokeStyle = '#003300';
    ctx.lineWidth = 1;
    const gridSize = 50;
    
    // Moving grid effect
    const offsetX = -player.x % gridSize;
    const offsetY = -player.y % gridSize;

    for(let x = offsetX; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for(let y = offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawNPCs() {
    npcsData.forEach(npc => {
        if(npc.cleared) return;

        // Draw NPC relative to player (camera follows player)
        // Actually, simpler logic: Map is static relative to screen for this demo? 
        // No, let's make the camera follow the player for true "exploration" feel.
        
        // Screen center is player position.
        // Object Screen X = (Object World X - Player World X) + Screen Center X
        const screenX = (npc.x - player.x) + canvas.width / 2;
        const screenY = (npc.y - player.y) + canvas.height / 2;

        // Draw logic only if on screen
        if(screenX > -50 && screenX < canvas.width + 50 && 
           screenY > -50 && screenY < canvas.height + 50) {
               
            ctx.save();
            ctx.fillStyle = npc.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = npc.color;
            
            // Draw a diamond shape for NPC
            ctx.beginPath();
            ctx.moveTo(screenX, screenY - 20);
            ctx.lineTo(screenX + 20, screenY);
            ctx.lineTo(screenX, screenY + 20);
            ctx.lineTo(screenX - 20, screenY);
            ctx.fill();
            
            // Name tag
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.font = '16px VT323';
            ctx.fillText(npc.name, screenX, screenY - 30);
            
            // "Q" mark floating
            ctx.fillStyle = '#000';
            ctx.fillText("?", screenX, screenY + 5);
            
            ctx.restore();
        }
    });
}

function render() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid();
    
    // Since we want the camera to follow player, player is always at center
    // But we draw NPCs based on offset.
    drawNPCs();

    // Draw Player (Always center)
    // Note: In the Player class update, we change x/y (world coordinates).
    // In draw, we draw at center of screen.
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    
    // Player glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ff41';
    ctx.fillStyle = '#fff';
    
    // Draw player circle
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
}

/**
 * Game Loop
 */
function loop() {
    if(gameState === 'PLAY') {
        handleInput();
        player.update();
        checkCollisions();
    }
    render();
    requestAnimationFrame(loop);
}

// Start Button
document.getElementById('start-btn').addEventListener('click', () => {
    startScreen.classList.add('hidden');
    
    // Reset player position to center relative to NPCs
    // NPCs are around mapRadius relative to center.
    // Let's set player world coordinates to center.
    player.x = canvas.width/2;
    player.y = canvas.height/2;
    
    // Recalculate NPC world positions based on current screen size to ensure they are around the start point
    npcsData.forEach((npc, index) => {
        const angle = (index / npcsData.length) * Math.PI * 2;
        npc.x = player.x + Math.cos(angle) * 300; // 300px radius
        npc.y = player.y + Math.sin(angle) * 300;
    });

    gameState = 'PLAY';
    loop();
});

</script>
</body>
</html>