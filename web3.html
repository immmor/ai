<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web3 æ¢ç´¢è€…ï¼šåˆ›ä¸–åŒºå—ä¹‹æ—…</title>
    <script src="web3questions.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            color: #00ff41;
            font-family: 'VT323', monospace;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background: radial-gradient(circle, #1a1a1a 0%, #000000 100%);
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.1);
            border: 2px solid #333;
        }

        /* UI Overlay */
        .ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #00ff41;
        }

        h1 { margin: 0; font-size: 2em; }
        p { margin: 5px 0; font-size: 1.2em; opacity: 0.8; }

        /* Dialogue / Quiz Modal */
        #modal {
            display: none;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 600px;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #00ff41;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.5);
            z-index: 10;
            text-align: center;
            box-sizing: border-box;
        }

        #modal h2 { margin-top: 0; color: #fff; font-size: 1.5em; }
        
        .option-btn {
            display: block;
            width: 100%;
            padding: 10px 15px;
            margin: 8px 0;
            background: #003300;
            border: 1px solid #00ff41;
            color: #00ff41;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1em;
            transition: 0.2s;
            box-sizing: border-box;
            min-height: 35px;
        }
        
        /* å°å±å¹•ä¼˜åŒ– */
        @media screen and (max-width: 600px) {
            #modal {
                width: 95%;
                padding: 15px;
                max-height: 90vh;
                overflow-y: auto;
            }
            
            #modal h2 {
                font-size: 1.3em;
                margin-bottom: 15px;
            }
            
            #modal-text {
                font-size: 1.2em;
                line-height: 1.4;
                margin-bottom: 20px;
                font-weight: bold;
            }
            
            .option-btn {
                padding: 12px 10px;
                font-size: 1em;
                margin: 8px 0;
                min-height: 40px;
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }
        
        /* è§¦æ‘¸å±ä¼˜åŒ– */
        @media (hover: none) and (pointer: coarse) {
            .option-btn {
                padding: 14px 15px;
                font-size: 1.1em;
                margin: 10px 0;
                min-height: 45px;
            }
        }

        .option-btn:hover, .option-btn:active {
            background: #00ff41;
            color: #000;
            transform: scale(1.02);
        }
        
        /* ç¡®ä¿æŒ‰é’®åœ¨å°å±å¹•ä¸Šæœ‰è¶³å¤Ÿçš„è§¦æ‘¸åŒºåŸŸ */
        .option-btn {
            touch-action: manipulation;
            user-select: none;
        }

        #interaction-hint {
    position: fixed;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 10px 20px;
    border-radius: 5px;
    font-size: 16px;
    opacity: 0;
    transition: opacity 0.3s;
    cursor: pointer;
    user-select: none;
}

/* è„‰åŠ¨åŠ¨ç”» */
@keyframes pulse {
    0% {
        transform: translateX(-50%) scale(1);
    }
    50% {
        transform: translateX(-50%) scale(1.1);
    }
    100% {
        transform: translateX(-50%) scale(1);
    }
}

        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        #start-btn {
            padding: 15px 40px;
            font-size: 2em;
            background: #00ff41;
            border: none;
            cursor: pointer;
            font-family: 'VT323', monospace;
            margin-top: 20px;
        }
        
        .hidden { display: none !important; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <div class="ui-layer">
        <h1>WEB3 æ¢ç´¢è€…</h1>
        <p>GASä½™é¢ (åˆ†æ•°): <span id="score">0</span> ETH</p>
        <p>å·²å‡»è´¥æ€ªç‰©: <span id="progress">0</span></p>
        <p>ç”Ÿå‘½å€¼: <span id="health">100</span>%</p>
        <div id="health-bar" style="width: 200px; height: 10px; background: #333; margin-top: 5px;">
            <div id="health-fill" style="width: 100%; height: 100%; background: #ff0000;"></div>
        </div>
    </div>

    <div id="interaction-hint">æŒ‰ [E] æ”»å‡»æ€ªç‰©</div>

    <div id="modal">
        <h2 id="modal-title">èŠ‚ç‚¹æé—®</h2>
        <p id="modal-text">é—®é¢˜å†…å®¹...</p>
        <div id="modal-options"></div>
    </div>

    <div id="start-screen">
        <h1 style="font-size: 4em; text-shadow: 0 0 20px #00ff41;">WEB3 UNIVERSE</h1>
        <p>é€šè¿‡å›ç­”é—®é¢˜æ”¶é›†åˆ›ä¸–åŒºå—ï¼Œæˆä¸ºå»ä¸­å¿ƒåŒ–å¤§å¸ˆã€‚</p>
        <button id="start-btn">è¿æ¥ä¸»ç½‘ (å¼€å§‹æ¸¸æˆ)</button>
    </div>
</div>

<script>
/**
 * Game Configuration & State
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const progressEl = document.getElementById('progress');
const hintEl = document.getElementById('interaction-hint');
const modal = document.getElementById('modal');
const modalTitle = document.getElementById('modal-title');
const modalText = document.getElementById('modal-text');
const modalOptions = document.getElementById('modal-options');
const startScreen = document.getElementById('start-screen');

let gameState = 'START'; // START, PLAY, QUIZ, WIN, GAME_OVER
let score = 0;
let defeatedCount = 0;
let lastSpawnTime = 0; // ä¸Šæ¬¡ç”Ÿæˆæ€ªç‰©çš„æ—¶é—´
let currentMonster = null; // å½“å‰æ­£åœ¨æˆ˜æ–—çš„æ€ªç‰©

// Resize canvas
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

/**
 * Game Data (The Knowledge Base)
 */

// æ€ªç‰©ç±»å‹å®šä¹‰
const monsterTypes = [
    { type: 'åŒºå—é“¾åƒµå°¸', color: '#ff0055', health: 20, reward: 5, size: 20 },
    { type: 'ç§é’¥çªƒè´¼', color: '#00ccff', health: 35, reward: 10, size: 25 },
    { type: 'Gasæ¶ˆè€—å…½', color: '#ffff00', health: 30, reward: 15, size: 30 },
    { type: 'æ™ºèƒ½åˆçº¦æ¼æ´', color: '#9d00ff', health: 50, reward: 20, size: 35 },
    { type: 'æŒ–çŸ¿éš¾åº¦æ€ª', color: '#ff8800', health: 60, reward: 25, size: 40 },
    { type: 'å…±è¯†ç ´åè€…', color: '#ff6666', health: 40, reward: 18, size: 32 },
    { type: 'å¥³å·«æ”»å‡»è€…', color: '#66ff66', health: 45, reward: 22, size: 28 }
];

// æ´»è·ƒæ€ªç‰©æ•°ç»„
let activeMonsters = [];
// æœ€å¤§åŒæ—¶å­˜åœ¨çš„æ€ªç‰©æ•°é‡
const MAX_MONSTERS = 5;
// æ€ªç‰©ç”Ÿæˆè®¡æ—¶å™¨
let spawnTimer = 0;
// æ€ªç‰©ç”Ÿæˆé—´éš”ï¼ˆæ¯«ç§’ï¼‰
const SPAWN_INTERVAL = 5000;

// ç”Ÿæˆéšæœºæ€ªç‰©
function spawnMonster() {
    if (activeMonsters.length >= MAX_MONSTERS) return;
    
    // éšæœºé€‰æ‹©æ€ªç‰©ç±»å‹
    const monsterType = monsterTypes[Math.floor(Math.random() * monsterTypes.length)];
    
    // åœ¨ç©å®¶å‘¨å›´éšæœºä½ç½®ç”Ÿæˆï¼Œä½†åœ¨å±å¹•è¾¹ç¼˜å¤–
    const angle = Math.random() * Math.PI * 2;
    const distance = canvas.width * 0.7; // åœ¨å±å¹•å¤–ç”Ÿæˆ
    const spawnX = player.x + Math.cos(angle) * distance;
    const spawnY = player.y + Math.sin(angle) * distance;
    
    // æ ¹æ®æ¦‚ç‡å†³å®šé—®é¢˜æ•°é‡
    let questionCount;
    const rand = Math.random();
    if (rand < 0.7) { // 70%æ¦‚ç‡ - 1ä¸ªé—®é¢˜
        questionCount = 1;
    } else if (rand < 0.9) { // 20%æ¦‚ç‡ - 2ä¸ªé—®é¢˜
        questionCount = 2;
    } else { // 10%æ¦‚ç‡ - 3ä¸ªé—®é¢˜
        questionCount = 3;
    }
    
    // æ ¹æ®é—®é¢˜æ•°é‡è°ƒæ•´å¥–åŠ±
    let adjustedReward = monsterType.reward;
    if (questionCount === 2) {
        adjustedReward = Math.floor(adjustedReward * 1.5);
    } else if (questionCount === 3) {
        adjustedReward = Math.floor(adjustedReward * 2);
    }
    
    // ä»é—®é¢˜åº“ä¸­éšæœºé€‰æ‹©æŒ‡å®šæ•°é‡çš„ä¸åŒé—®é¢˜
    const selectedQuestions = [];
    const availableQuestions = [...blockchainQuestions];
    
    for (let i = 0; i < questionCount && availableQuestions.length > 0; i++) {
        const randomIndex = Math.floor(Math.random() * availableQuestions.length);
        selectedQuestions.push(availableQuestions.splice(randomIndex, 1)[0]);
    }
    
    // åˆ›å»ºæ€ªç‰©å¯¹è±¡
    const monster = {
        id: Date.now(), // ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå”¯ä¸€ID
        x: spawnX,
        y: spawnY,
        targetX: player.x,
        targetY: player.y,
        type: monsterType.type,
        color: monsterType.color,
        health: monsterType.health,
        size: monsterType.size,
        speed: 1 + Math.random() * 2, // 1-3çš„éšæœºé€Ÿåº¦
        reward: adjustedReward,
        questions: selectedQuestions,
        currentQuestionIndex: 0,
        defeated: false
    };
    
    activeMonsters.push(monster);
}

/**
 * Player Class
 */
class Player {
    constructor() {
        this.x = canvas.width / 2;
        this.y = canvas.height / 2;
        this.size = 20;
        this.speed = 7;
        this.dragSpeed = 10;
        this.color = '#fff';
        this.vx = 0;
        this.vy = 0;
        this.health = 100; // æ·»åŠ ç”Ÿå‘½å€¼
        this.lastHealth = 100;
    }

    update() {
        // ç§»åŠ¨æ§åˆ¶
        let moveX = 0;
        let moveY = 0;
        
        // é”®ç›˜æ§åˆ¶
        if (keys['w'] || keys['arrowup']) moveY -= this.speed;
        if (keys['s'] || keys['arrowdown']) moveY += this.speed;
        if (keys['a'] || keys['arrowleft']) moveX -= this.speed;
        if (keys['d'] || keys['arrowright']) moveX += this.speed;
        
        // æ‹–æ‹½æ§åˆ¶ï¼ˆè§¦æ‘¸å±å’Œé¼ æ ‡ï¼‰
        if (isDragging) {
            // ä½¿ç”¨æ‹–æ‹½åç§»é‡ï¼Œä½†é™åˆ¶æœ€å¤§é€Ÿåº¦ï¼Œå¹¶åè½¬æ–¹å‘ä½¿æ§åˆ¶æ›´ç›´è§‚
            const dragMag = Math.sqrt(dragOffsetX * dragOffsetX + dragOffsetY * dragOffsetY);
            if (dragMag > 0) {
                moveX -= (dragOffsetX / dragMag) * this.dragSpeed;
                moveY -= (dragOffsetY / dragMag) * this.dragSpeed;
            }
        }
        
        // è§„èŒƒåŒ–å‘é‡ä»¥ä¿æŒå¯¹è§’çº¿ç§»åŠ¨é€Ÿåº¦ä¸€è‡´
        const magnitude = Math.sqrt(moveX * moveX + moveY * moveY);
        if (magnitude > 0) {
            moveX = (moveX / magnitude) * Math.max(this.speed, magnitude * 0.1);
            moveY = (moveY / magnitude) * Math.max(this.speed, magnitude * 0.1);
        }
        
        // æ›´æ–°ä½ç½®
        this.x += moveX;
        this.y += moveY;

        // ç§»é™¤è¾¹ç•Œæ£€æŸ¥ï¼Œå®ç°å¼€æ”¾å¼åœ°å›¾
    }

    draw() {
        ctx.save();
        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size/2, 0, Math.PI*2);
        ctx.fill();
        
        // Direction indicator (triangle)
        ctx.fillStyle = '#00ff41';
        ctx.beginPath();
        ctx.moveTo(this.x, this.y - 15);
        ctx.lineTo(this.x - 5, this.y - 5);
        ctx.lineTo(this.x + 5, this.y - 5);
        ctx.fill();
        ctx.restore();
    }
    
    takeDamage(amount) {
        this.health -= amount;
        if (this.health < 0) this.health = 0;
        
        // æ›´æ–°UIæ˜¾ç¤º
        updateHealthBar();
        
        return this.health <= 0;
    }
}

const player = new Player();

// æ›´æ–°ç”Ÿå‘½å€¼UI
function updateHealthBar() {
    const healthEl = document.getElementById('health');
    const healthFill = document.getElementById('health-fill');
    healthEl.innerText = player.health;
    healthFill.style.width = `${player.health}%`;
    
    // æ ¹æ®ç”Ÿå‘½å€¼æ”¹å˜é¢œè‰²
    if (player.health > 60) {
        healthFill.style.backgroundColor = '#ff0000';
    } else if (player.health > 30) {
        healthFill.style.backgroundColor = '#ffff00';
    } else {
        healthFill.style.backgroundColor = '#ff0000';
    }
}

/**
 * Input Handling
 */
const keys = {};
// è§¦æ‘¸å±æ§åˆ¶
let isDragging = false;
let lastTouchX = 0;
let lastTouchY = 0;
let dragOffsetX = 0;
let dragOffsetY = 0;

window.addEventListener('keydown', (e) => {
    keys[e.key.toLowerCase()] = true;
    if(e.key === 'e' || e.key === 'E') tryInteract();
});
window.addEventListener('keyup', (e) => {
    keys[e.key.toLowerCase()] = false;
});

// è§¦æ‘¸å±è§¦æ‘¸å¼€å§‹äº‹ä»¶
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
    
    const touch = e.touches[0];
    isDragging = true;
    lastTouchX = touch.clientX;
    lastTouchY = touch.clientY;
    dragOffsetX = 0;
    dragOffsetY = 0;
}, { passive: false });

// è§¦æ‘¸å±è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
canvas.addEventListener('touchmove', (e) => {
    e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
    
    if (isDragging && gameState === 'PLAY') {
        const touch = e.touches[0];
        const deltaX = touch.clientX - lastTouchX;
        const deltaY = touch.clientY - lastTouchY;
        
        // æ›´æ–°ç©å®¶ç§»åŠ¨æ–¹å‘ï¼ˆåå‘ï¼Œå› ä¸ºæ‹–æ‹½æ˜¯è®©èƒŒæ™¯ç§»åŠ¨ï¼Œç›¸å½“äºç©å®¶å‘ç›¸åæ–¹å‘ç§»åŠ¨ï¼‰
        dragOffsetX = -deltaX;
        dragOffsetY = -deltaY;
        
        lastTouchX = touch.clientX;
        lastTouchY = touch.clientY;
    }
}, { passive: false });

// è§¦æ‘¸å±è§¦æ‘¸ç»“æŸäº‹ä»¶
canvas.addEventListener('touchend', () => {
    isDragging = false;
    dragOffsetX = 0;
    dragOffsetY = 0;
});

// é¼ æ ‡æ‹–æ‹½æ”¯æŒ
canvas.addEventListener('mousedown', (e) => {
    if (e.button === 0) { // å·¦é”®
        isDragging = true;
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
        dragOffsetX = 0;
        dragOffsetY = 0;
    }
});

canvas.addEventListener('mousemove', (e) => {
    if (isDragging && gameState === 'PLAY') {
        const deltaX = e.clientX - lastTouchX;
        const deltaY = e.clientY - lastTouchY;
        
        // æ›´æ–°ç©å®¶ç§»åŠ¨æ–¹å‘ï¼ˆåå‘ï¼‰
        dragOffsetX = -deltaX;
        dragOffsetY = -deltaY;
        
        lastTouchX = e.clientX;
        lastTouchY = e.clientY;
    }
});

window.addEventListener('mouseup', () => {
    isDragging = false;
    dragOffsetX = 0;
    dragOffsetY = 0;
});

// ç‚¹å‡»æ”»å‡»æŒ‰é’®äº‹ä»¶
const interactionBtn = document.getElementById('interaction-hint');
interactionBtn.addEventListener('click', () => {
    if (gameState === 'PLAY' && currentMonster) {
        tryInteract();
    }
});

function handleInput() {
    if(gameState !== 'PLAY') return;

    player.vx = 0;
    player.vy = 0;

    if(keys['w'] || keys['arrowup']) player.vy = -player.speed;
    if(keys['s'] || keys['arrowdown']) player.vy = player.speed;
    if(keys['a'] || keys['arrowleft']) player.vx = -player.speed;
    if(keys['d'] || keys['arrowright']) player.vx = player.speed;
}

/**
 * Game Logic
 */

// æ›´æ–°æ€ªç‰©ä½ç½®å’Œè¡Œä¸º
function updateMonsters() {
    activeMonsters = activeMonsters.filter(monster => !monster.defeated);
    
    activeMonsters.forEach(monster => {
        // æ›´æ–°ç›®æ ‡ä½ç½®ï¼ˆè¿½è¸ªç©å®¶ï¼‰
        monster.targetX = player.x;
        monster.targetY = player.y;
        
        // è®¡ç®—ç§»åŠ¨æ–¹å‘
        const dx = monster.targetX - monster.x;
        const dy = monster.targetY - monster.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 0) {
            monster.x += (dx / dist) * monster.speed;
            monster.y += (dy / dist) * monster.speed;
        }
    });
}

// æ£€æŸ¥ç©å®¶ä¸æ€ªç‰©çš„ç¢°æ’
function checkCollisions() {
    // å¦‚æœæ­£åœ¨æˆ˜æ–—ä¸­ï¼Œä¸æ˜¾ç¤ºäº¤äº’æç¤º
    if (gameState === 'QUIZ') {
        hintEl.style.display = 'none';
        return;
    }
    
    let nearAny = false;
    currentMonster = null;
    
    activeMonsters.forEach(monster => {
        if(monster.defeated) return;
        
        const dx = player.x - monster.x;
        const dy = player.y - monster.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        // å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œæ€ªç‰©æ”»å‡»ç©å®¶
        if (dist < (player.size/2 + monster.size/2)) {
            // æ€ªç‰©æ”»å‡»ç©å®¶
            if (Math.random() < 0.1) { // 10%çš„æ¦‚ç‡æ”»å‡»
                player.takeDamage(5);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }
        
        // äº¤äº’åŠå¾„
        if (dist < 80) {
            nearAny = true;
            currentMonster = monster;
        }
    });
    
    if (nearAny && gameState === 'PLAY') {
        hintEl.style.display = 'block';
        hintEl.style.opacity = '1';
        // æ·»åŠ è„‰åŠ¨åŠ¨ç”»æç¤º
        hintEl.style.animation = 'pulse 2s infinite';
    } else {
        hintEl.style.display = 'none';
        hintEl.style.opacity = '0';
        hintEl.style.animation = 'none';
    }
}

// æ¸¸æˆç»“æŸ
function gameOver() {
    gameState = 'GAME_OVER';
    alert(`ğŸ’€ æ¸¸æˆç»“æŸï¼ä½ è¢«åŒºå—é“¾æ€ªç‰©å‡»è´¥äº†ï¼\næœ€ç»ˆå¾—åˆ†: ${score} ETH\nå‡»è´¥çš„æ€ªç‰©: ${defeatedCount} ä¸ª`);
    location.reload();
}

function tryInteract() {
    if(gameState === 'PLAY' && currentMonster) {
        // å¼€å§‹ä¸æ€ªç‰©çš„æˆ˜æ–—é—®ç­”
        startMonsterBattle(currentMonster);
    }
}

function startMonsterBattle(monster) {
    currentMonster = monster;
    monster.currentQuestionIndex = 0;
    askMonsterQuestion();
}

// èƒ½é‡é“å…·ç±»
class EnergyPotion {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 15;
        this.color = '#FFD700'; // é‡‘è‰²
        this.pulse = 0; // ç”¨äºè„‰å†²åŠ¨ç”»æ•ˆæœ
        this.pulseSpeed = 0.05;
        this.healthRestore = 20; // æ¢å¤20ç‚¹ç”Ÿå‘½å€¼
    }
    
    update() {
        // æ›´æ–°è„‰å†²åŠ¨ç”»
        this.pulse += this.pulseSpeed;
        if (this.pulse > Math.PI * 2) {
            this.pulse = 0;
        }
    }
    
    draw(ctx) {
        // è®¡ç®—å±å¹•ä¸Šçš„ä½ç½®ï¼ˆè€ƒè™‘ä¸–ç•Œåç§»ï¼‰
        const screenX = this.x - player.x + canvas.width / 2;
        const screenY = this.y - player.y + canvas.height / 2;
        
        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        if (screenX > -this.radius * 2 && screenX < canvas.width + this.radius * 2 &&
            screenY > -this.radius * 2 && screenY < canvas.height + this.radius * 2) {
            
            // ç»˜åˆ¶è„‰å†²æ•ˆæœ
            const pulseRadius = this.radius * (1 + 0.3 * Math.sin(this.pulse));
            ctx.beginPath();
            ctx.arc(screenX, screenY, pulseRadius, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 215, 0, ${0.2 * (1 + Math.sin(this.pulse))})`;
            ctx.fill();
            
            // ç»˜åˆ¶èƒ½é‡é“å…·ä¸»ä½“
            ctx.beginPath();
            ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = this.color;
            ctx.fill();
            
            // ç»˜åˆ¶åå­—ç¬¦å·
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(screenX - 8, screenY);
            ctx.lineTo(screenX + 8, screenY);
            ctx.moveTo(screenX, screenY - 8);
            ctx.lineTo(screenX, screenY + 8);
            ctx.stroke();
        }
    }
    
    checkCollision(player) {
        const dx = this.x - player.x;
        const dy = this.y - player.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < this.radius + player.size/2;
    }
}

// æ´»è·ƒçš„èƒ½é‡é“å…·æ•°ç»„
let activePotions = [];
// èƒ½é‡é“å…·ç”Ÿæˆè®¾ç½®
//const maxEnergyPotions = 10;
//const energySpawnChance = 0.005; // æ¯å¸§ç”Ÿæˆèƒ½é‡é“å…·çš„æ¦‚ç‡
const energySpawnInterval = 15000; // å›ºå®šé—´éš”ç”Ÿæˆ(æ¯«ç§’)
let energySpawnTimer = null;

function askMonsterQuestion() {
    if (!currentMonster || currentMonster.currentQuestionIndex >= currentMonster.questions.length) {
        return;
    }
    
    gameState = 'QUIZ';
    hintEl.style.display = 'none';
    modal.style.display = 'block';
    
    const currentQuestion = currentMonster.questions[currentMonster.currentQuestionIndex];
    modalTitle.innerText = `${currentMonster.type} - é—®é¢˜ ${currentMonster.currentQuestionIndex + 1}/${currentMonster.questions.length}`;
    modalText.innerText = currentQuestion.question;
    modalOptions.innerHTML = '';
    
    // æ‰“ä¹±é€‰é¡¹é¡ºåº
    const shuffledOptions = shuffleArray([...currentQuestion.options]);
    
    shuffledOptions.forEach(opt => {
        const btn = document.createElement('button');
        btn.className = 'option-btn';
        btn.innerText = opt.text;
        btn.onclick = () => handleAnswer(opt.correct);
        modalOptions.appendChild(btn);
    });
}

function handleAnswer(isCorrect) {
    if (isCorrect) {
        modalText.innerText = "âœ… å›ç­”æ­£ç¡®ï¼å¯¹æ€ªç‰©é€ æˆä¼¤å®³ï¼";
        
        // å¯¹æ€ªç‰©é€ æˆä¼¤å®³
        currentMonster.health -= 30; // æ¯ä¸ªæ­£ç¡®ç­”æ¡ˆé€ æˆ30ç‚¹ä¼¤å®³
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯æœ€åä¸€ä¸ªé—®é¢˜
        const isLastQuestion = currentMonster.currentQuestionIndex === currentMonster.questions.length - 1;
        
        if (currentMonster.health <= 0) {
            // æ€ªç‰©è¢«å‡»è´¥
            modalText.innerText = "ğŸ’¥ æ€ªç‰©è¢«å‡»è´¥ï¼è·å¾—å¥–åŠ±ï¼";
            // ç¡®ä¿currentMonsterå¯¹è±¡è¢«å¼•ç”¨ï¼Œé¿å…åœ¨finishBattleä¸­ä¸¢å¤±
            const defeatedMonster = currentMonster;
            modalOptions.innerHTML = `<button class="option-btn" onclick="finishBattle(true)">ç»§ç»­æ¢ç´¢</button>`;
        } else if (isLastQuestion) {
            // æœ€åä¸€ä¸ªé—®é¢˜ä½†æ€ªç‰©æœªè¢«å‡»è´¥ï¼Œä»ç„¶ç»“æŸæˆ˜æ–—
            modalOptions.innerHTML = '<button class="option-btn" onclick="finishBattle(false)">ç»§ç»­æ¢ç´¢</button>';
        } else {
            // ä¸æ˜¯æœ€åä¸€ä¸ªé—®é¢˜ä¸”æ€ªç‰©æœªè¢«å‡»è´¥ï¼Œç»§ç»­æˆ˜æ–—
            modalOptions.innerHTML = '<button class="option-btn" onclick="continueBattle()">ç»§ç»­æ”»å‡»</button>';
        }
    } else {
        modalText.innerText = "âŒ å›ç­”é”™è¯¯ï¼å—åˆ°åå‡»ï¼";
        
        // ç©å®¶å—åˆ°ä¼¤å®³
        player.takeDamage(10);
        
        // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
        if (player.health <= 0) {
            // ä¿å­˜å½“å‰æ€ªç‰©çŠ¶æ€ç”¨äºç»“æŸæˆ˜æ–—
            const monsterToFinish = currentMonster;
            // å…ˆæ¸…é™¤modalï¼Œé¿å…æ˜¾ç¤ºä¸¤æ¬¡
            modal.style.display = 'none';
            // å…ˆç»“æŸå½“å‰æˆ˜æ–—ï¼Œå†è°ƒç”¨gameOver
            finishBattle(false);
            // è°ƒç”¨gameOver
            gameOver();
            return;
        }
        
        // å¯¹äºå›ç­”é”™è¯¯çš„æƒ…å†µï¼Œä¸å†é‡å¤åŒä¸€ä¸ªé—®é¢˜ï¼Œç›´æ¥ç»“æŸæˆ˜æ–—
        modalOptions.innerHTML = '<button class="option-btn" onclick="finishBattle(false)">ç»§ç»­æ¢ç´¢</button>';
    }
}

function continueBattle() {
    if (!currentMonster || currentMonster.defeated) {
        return; // å®‰å…¨æ£€æŸ¥ï¼Œé¿å…å¤„ç†æ— æ•ˆæ€ªç‰©
    }
    
    // è¿›å…¥ä¸‹ä¸€ä¸ªé—®é¢˜
    currentMonster.currentQuestionIndex++;
    
    // ç¡®ä¿ä¸ä¼šè¶…å‡ºé—®é¢˜èŒƒå›´
    if (currentMonster.currentQuestionIndex < currentMonster.questions.length) {
        askMonsterQuestion();
    } else {
        // æ‰€æœ‰é—®é¢˜éƒ½å·²é—®å®Œï¼Œç»“æŸæˆ˜æ–—
        finishBattle(currentMonster.health <= 0);
    }
}

function finishBattle(success) {
    // ç¡®ä¿modalè¢«éšè—
    modal.style.display = 'none';
    gameState = 'PLAY';
    
    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿currentMonsterå­˜åœ¨ä¸”æœªè¢«å¤„ç†è¿‡
    if (currentMonster) {
        if(success) {
            // å¢åŠ åˆ†æ•°å’Œå‡»è´¥è®¡æ•°
            score += currentMonster.reward;
            defeatedCount++;
            
            // æ ‡è®°æ€ªç‰©ä¸ºå·²å‡»è´¥
            currentMonster.defeated = true;
            
            // æ›´æ–°UI
            scoreEl.innerText = score;
            progressEl.innerText = defeatedCount;
            
            // éšæœºæ¢å¤ä¸€äº›ç”Ÿå‘½å€¼
            player.health = Math.min(100, player.health + Math.floor(Math.random() * 15) + 5);
            updateHealthBar();
        }
        
        // æ— è®ºæˆåŠŸå¤±è´¥ï¼Œéƒ½æ¸…é™¤å½“å‰æ€ªç‰©å¼•ç”¨ï¼Œé¿å…é‡å¤å¤„ç†
        currentMonster = null;
    }
}

// å·¥å…·å‡½æ•°ï¼šæ‰“ä¹±æ•°ç»„é¡ºåº
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * Rendering
 */
function drawGrid() {
    ctx.strokeStyle = '#003300';
    ctx.lineWidth = 1;
    const gridSize = 50;
    
    // Moving grid effect
    const offsetX = -player.x % gridSize;
    const offsetY = -player.y % gridSize;

    for(let x = offsetX; x < canvas.width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for(let y = offsetY; y < canvas.height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
}

function drawMonsters() {
    activeMonsters.forEach(monster => {
        if(monster.defeated) return;

        // è®¡ç®—å±å¹•ä½ç½®ï¼ˆæ‘„åƒæœºè·Ÿéšç©å®¶ï¼‰
        const screenX = (monster.x - player.x) + canvas.width / 2;
        const screenY = (monster.y - player.y) + canvas.height / 2;

        // åªåœ¨å±å¹•èŒƒå›´å†…ç»˜åˆ¶
        if(screenX > -100 && screenX < canvas.width + 100 && 
           screenY > -100 && screenY < canvas.height + 100) {
               
            ctx.save();
            
            // ç»˜åˆ¶æ€ªç‰©èº«ä½“
            ctx.fillStyle = monster.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = monster.color;
            
            // ç»˜åˆ¶æ€ªç‰©å½¢çŠ¶ï¼ˆåœ†å½¢ï¼‰
            ctx.beginPath();
            ctx.arc(screenX, screenY, monster.size/2, 0, Math.PI*2);
            ctx.fill();
            
            // ç»˜åˆ¶ç”Ÿå‘½å€¼æ¡
            const barWidth = monster.size;
            const barHeight = 5;
            ctx.fillStyle = '#333';
            ctx.fillRect(screenX - barWidth/2, screenY - monster.size/2 - 15, barWidth, barHeight);
            
            ctx.fillStyle = monster.health > 50 ? '#00ff00' : monster.health > 25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(screenX - barWidth/2, screenY - monster.size/2 - 15, (barWidth * monster.health) / (monsterTypes.find(mt => mt.type === monster.type).health), barHeight);
            
            // æ€ªç‰©åç§°
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.font = '14px VT323';
            ctx.fillText(monster.type, screenX, screenY - monster.size/2 - 25);
            
            // é—®é¢˜æ ‡è®°
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(screenX, screenY, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = '12px VT323';
            ctx.fillText("?", screenX - 2, screenY + 3);
            
            ctx.restore();
        }
    });
}

function render() {
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawGrid();
    
    // ç»˜åˆ¶èƒ½é‡é“å…·
    energyPotions.forEach(potion => potion.draw(ctx));
    
    // ç»˜åˆ¶æ€ªç‰©ï¼ˆç›¸å¯¹äºç©å®¶çš„ä½ç½®ï¼‰
    drawMonsters();

    // ç»˜åˆ¶ç©å®¶ï¼ˆå§‹ç»ˆåœ¨å±å¹•ä¸­å¿ƒï¼‰
    ctx.save();
    ctx.translate(canvas.width/2, canvas.height/2);
    
    // Player glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ff41';
    ctx.fillStyle = '#fff';
    
    // Draw player circle - ç§»é™¤ä¸‰è§’å½¢æŒ‡ç¤ºå™¨
    ctx.beginPath();
    ctx.arc(0, 0, 10, 0, Math.PI*2);
    ctx.fill();
    
    ctx.restore();
    
    // ç»˜åˆ¶é€šçŸ¥
    notifications.forEach(notification => notification.draw(ctx));
}

// é€šçŸ¥ç±»
class Notification {
    constructor(text, x, y, duration = 2000) {
        this.text = text;
        this.x = x;
        this.y = y;
        this.duration = duration;
        this.createdAt = Date.now();
        this.opacity = 1;
        this.offset = 0;
    }
    
    update() {
        const age = Date.now() - this.createdAt;
        this.offset -= 0.5; // å‘ä¸Šç§»åŠ¨
        
        // æ·¡å‡ºæ•ˆæœ
        if (age > this.duration * 0.7) {
            this.opacity = 1 - (age - this.duration * 0.7) / (this.duration * 0.3);
        }
    }
    
    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        ctx.font = '20px Arial';
        ctx.fillStyle = '#4CAF50';
        ctx.textAlign = 'center';
        ctx.fillText(this.text, this.x, this.y + this.offset);
        ctx.restore();
    }
    
    isExpired() {
        return Date.now() - this.createdAt > this.duration;
    }
}

// é€šçŸ¥æ•°ç»„
let notifications = [];

// æ˜¾ç¤ºé€šçŸ¥
function showNotification(text) {
    const notification = new Notification(text, canvas.width / 2, canvas.height / 4);
    notifications.push(notification);
}

// èƒ½é‡é“å…·ç”Ÿæˆé…ç½®
const energySpawnChance = 0.005;
const maxEnergyPotions = 3;

// èƒ½é‡é“å…·æ•°ç»„
let energyPotions = [];

// ç”Ÿæˆèƒ½é‡é“å…·
function spawnEnergyPotion() {
    const x = Math.random() * canvas.width;
    const y = Math.random() * canvas.height;
    energyPotions.push(new EnergyPotion(x, y));
}

// å¤„ç†èƒ½é‡é“å…·ç¢°æ’
function handleEnergyCollision() {
    energyPotions = energyPotions.filter(potion => {
        if (potion.checkCollision(player)) {
            player.health = Math.min(100, player.health + potion.healthRestore);
            updateHealthBar();
            showNotification(`+${potion.healthRestore} ç”Ÿå‘½å€¼`);
            return false;
        }
        return true;
    });
}

/**
 * Game Loop
 */
function loop(timestamp) {
    if(gameState === 'PLAY') {
        handleInput();
        player.update();
        updateMonsters();
        checkCollisions();
        
        // æ›´æ–°èƒ½é‡é“å…·
        energyPotions.forEach(potion => potion.update());
        
        // å¤„ç†èƒ½é‡é“å…·ç¢°æ’
        handleEnergyCollision();
        
        // æ›´æ–°é€šçŸ¥
        notifications.forEach(notification => notification.update());
        notifications = notifications.filter(notification => !notification.isExpired());
        
        // æ§åˆ¶æ€ªç‰©ç”Ÿæˆ
        if (!lastSpawnTime) lastSpawnTime = timestamp;
        if (timestamp - lastSpawnTime > SPAWN_INTERVAL) {
            spawnMonster();
            lastSpawnTime = timestamp;
        }
        
        // èƒ½é‡é“å…·ç”±å®šæ—¶å™¨ç”Ÿæˆï¼Œä¸å†éœ€è¦æ¯å¸§æ£€æŸ¥
    }
    render();
    requestAnimationFrame(loop);
}

// å…¨å±€å˜é‡ï¼Œä½¿closeModalç­‰å‡½æ•°åœ¨windowä½œç”¨åŸŸä¸­å¯ç”¨
window.closeModal = finishBattle;

// Start Button
document.getElementById('start-btn').addEventListener('click', () => {
    startScreen.classList.add('hidden');
    
    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
    if (energySpawnTimer) {
        clearInterval(energySpawnTimer);
    }
    
    // è®¾ç½®ç©å®¶åˆå§‹ä½ç½®
    player.x = 0;
    player.y = 0;
    
    // åˆå§‹åŒ–ç”Ÿå‘½å€¼æ˜¾ç¤º
    updateHealthBar();
    
    // åˆå§‹ç”Ÿæˆå‡ ä¸ªæ€ªç‰©
    for (let i = 0; i < 3; i++) {
        setTimeout(spawnMonster, i * 1000);
    }
    
    // ç”Ÿæˆåˆå§‹èƒ½é‡é“å…·
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            if (gameState === 'PLAY' && energyPotions.length < maxEnergyPotions) {
                spawnEnergyPotion();
            }
        }, i * 2000);
    }
    
    // è®¾ç½®èƒ½é‡é“å…·å®šæ—¶ç”Ÿæˆå™¨
    energySpawnTimer = setInterval(() => {
        if (gameState === 'PLAY' && energyPotions.length < maxEnergyPotions) {
            spawnEnergyPotion();
        }
    }, energySpawnInterval);

    gameState = 'PLAY';
    requestAnimationFrame(loop);
});

</script>
</body>
</html>